

<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>py_entitymatching 0.3.2 documentation</title>
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/language_data.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">py_entitymatching 0.3.2 documentation</a> &#187;</li> 
      </ul>
    </div>
<div class="content-wrapper">
    <div class="content">
        <div class="document">
            <div class="sphinxsidebar">
                <h3>Table Of Contents</h3>
                <p class="caption"><span class="caption-text">How To Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-how_to_guide">How to Guide To Do Entity Matching</a></li>
</ul>
<p class="caption"><span class="caption-text">User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/whatisnew">What is New?</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/installation">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/overview">Overview of Supported EM Processes</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/guides">Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/datastructures">Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/steps_supp_em_workflows">Steps of Supported EM Workflows</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/misc">Miscellaneous</a></li>
</ul>
<p class="caption"><span class="caption-text">API Reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/api/overview">Overview of Command Organization</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-user_manual/api/actual_commands">Commands in py_entitymatching</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#experimental-commands">Experimental Commands</a></li>
</ul>

                <h3 style="margin-top: 1.5em;">Search</h3>

                <form class="search" action="search.html" method="get">
                    <input type="text" name="q" size="18"/>
                    <input type="submit" value="Go"/>
                    <input type="hidden" name="check_keywords" value="yes"/>
                    <input type="hidden" name="area" value="default"/>
                </form>
                <p class="searchtip" style="font-size: 90%">
                    Enter search terms or a module, class or function name.
                </p>

            </div>
             
            <div class="documentwrapper">
                <div class="bodywrapper">
                    <div class="body">
                        
  <div class="section" id="user-manual-for-py-entitymatching">
<h1>User Manual for py_entitymatching<a class="headerlink" href="#user-manual-for-py-entitymatching" title="Permalink to this headline">¶</a></h1>
<p>This document explains how to install and use the package.
To contribute to the package, see the
<a class="reference external" href="https://sites.google.com/site/anhaidgroup/projects/py_entitymatching">project website</a>,
section “For Contributors and Developers”.</p>
</div>
<div class="section" id="contents">
<h1>Contents<a class="headerlink" href="#contents" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-how_to_guide"></span><div class="section" id="how-to-guide-to-do-entity-matching">
<h2>How to Guide To Do Entity Matching<a class="headerlink" href="#how-to-guide-to-do-entity-matching" title="Permalink to this headline">¶</a></h2>
<p>The initial draft of the how to guide to do entity matching can be found <a class="reference external" href="http://pradap-www.cs.wisc.edu/magellan/how-to-guide/how_to_guide_magellan.pdf">here.</a></p>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-user_manual/whatisnew"></span><div class="section" id="what-is-new">
<h2>What is New?<a class="headerlink" href="#what-is-new" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>Compared to Version 0.3.1, the followings are new:</dt><dd><ul class="simple">
<li><p>Cython version was updated. The package is now built with updated Cython version &gt;= 0.27.3.</p></li>
<li><p>Added support for Python 3.7 version and dropped Testing support for Python 3.4 version.</p></li>
</ul>
</dd>
</dl>
</div>
<span id="document-user_manual/installation"></span><div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="requirements">
<h3>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Python 2.7 or Python 3.5+</p></li>
</ul>
</div>
<div class="section" id="platforms">
<h3>Platforms<a class="headerlink" href="#platforms" title="Permalink to this headline">¶</a></h3>
<p>py_entitymatching has been tested on Linux (Redhat enterprise Linux with 2.6
.32 kernel), OS X (Sierra), and Windows 10.</p>
</div>
<div class="section" id="dependencies">
<h3>Dependencies<a class="headerlink" href="#dependencies" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>pandas (provides data structures to store and manage tables)</p></li>
<li><p>scikit-learn (provides implementations for common machine learning algorithms)</p></li>
<li><p>joblib (provides multiprocessing capabilities)</p></li>
<li><p>pyqt5 (provides tools to build GUIs)</p></li>
<li><p>py_stringsimjoin (provides implementations for string similarity joins)</p></li>
<li><p>py_stringmatching (provides a set of string tokenizers and string similarity functions)</p></li>
<li><p>cloudpickle (provides functions to serialize Python constructs)</p></li>
<li><p>pyprind (library to display progress indicators)</p></li>
<li><p>pyparsing (library to parse strings)</p></li>
<li><p>six (provides functions to write compatible code across Python 2 and 3)</p></li>
<li><p>xgboost (provides an implementation for xgboost classifier)</p></li>
<li><p>pandas-profiling (provides implementation for profiling pandas dataframe)</p></li>
<li><p>pandas-table (provides data exploration tool for pandas dataframe)</p></li>
<li><p>openrefine (provides data exploration tool for tables)</p></li>
<li><p>ipython (provides better tools for displaying tables in notebooks)</p></li>
<li><p>scipy (dependency for skikit-learn)</p></li>
</ul>
</div>
<div class="section" id="c-compiler-required">
<h3>C Compiler Required<a class="headerlink" href="#c-compiler-required" title="Permalink to this headline">¶</a></h3>
<p>Installing Using conda
Before installing this package, you need to make sure that you have a C compiler installed. This is necessary because this package contains Cython files. Go <a class="reference external" href="https://sites.google.com/site/anhaidgroup/projects/magellan/issues">here</a> for more information about how to check whether you already have a C compiler and how to install a C compiler. After you have confirmed that you have a C compiler installed, you are ready to install py_entitymatching.</p>
</div>
<div class="section" id="installing-using-pip">
<h3>Installing Using pip<a class="headerlink" href="#installing-using-pip" title="Permalink to this headline">¶</a></h3>
<p>To install the package using pip, execute the following
command:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">numpy</span> <span class="n">scipy</span> <span class="n">py_entitymatching</span>
</pre></div>
</div>
<p>The above command will install py_entitymatching and all of its dependencies except
XGBoost, pandastable, openrefine, and PyQt5. This is because pip can only install the
dependency packages that are available in PyPI and PyQt5, XGBoost, pandastable are not
in PyPI for Python 2.</p>
<ul class="simple">
<li><p>To install PyQt5, follow the instructions at <a class="reference external" href="http://pyqt.sourceforge.net/Docs/PyQt5/installation.html">this page</a>.</p></li>
<li><p>To install XGBoost, follow the instructions at <a class="reference external" href="https://XGBoost.readthedocs.io/en/latest/build.html">this page</a>.</p></li>
<li><p>To install pandastable follow the instructions at <a class="reference external" href="https://github.com/dmnfarrell/pandastable">this page</a>.</p></li>
<li><p>To install openrefine follow the instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">this page</a>.</p></li>
</ul>
</div>
<div class="section" id="installing-from-source-distribution">
<h3>Installing from Source Distribution<a class="headerlink" href="#installing-from-source-distribution" title="Permalink to this headline">¶</a></h3>
<p>Clone the py_entitymatching package from GitHub</p>
<blockquote>
<div><p>git clone  <a class="reference external" href="https://github.com/anhaidgroup/py_entitymatching.git">https://github.com/anhaidgroup/py_entitymatching.git</a></p>
</div></blockquote>
<p>Then,  execute the following commands from the package root:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="n">install</span> <span class="o">-</span><span class="n">U</span> <span class="n">numpy</span> <span class="n">scipy</span>
<span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span>
</pre></div>
</div>
<p>which installs py_stringmatching into the default Python directory on your machine. If you do not have installation permission for that directory then you can install the package in your
home directory as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">setup</span><span class="o">.</span><span class="n">py</span> <span class="n">install</span> <span class="o">--</span><span class="n">user</span>
</pre></div>
</div>
<p>For more information see this StackOverflow <a class="reference external" href="http://stackoverflow.com/questions/14179941/how-to-install-python-packages-without-root-privileges">link</a>.</p>
<p>The above commands will install py_entitymatching and all of its
dependencies, except PyQt5 and XGBoost.</p>
<p>This is  because, similar to pip, setup.py can only install the dependency packages
that are available in PyPI and PyQt5, pandastable, XGBoost are not in PyPI for Python 2.</p>
<ul class="simple">
<li><p>To install PyQt5, follow the instructions at <a class="reference external" href="http://pyqt.sourceforge.net/Docs/PyQt5/installation.html">this page</a>.</p></li>
<li><p>To install XGBoost, follow the instructions at <a class="reference external" href="https://XGBoost.readthedocs.io/en/latest/build.html">this page</a>.</p></li>
<li><p>To install pandastable follow the instructions at <a class="reference external" href="https://github.com/dmnfarrell/pandastable">this page</a>.</p></li>
<li><p>To install openrefine follow the instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">this page</a>.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, py_entitymatching supports a set of experimental commands that help users
create an EM workflow. Some of these commands will require installing Dask. To
install dask refer to this <a href="#id8"><span class="problematic" id="id9">`page &lt;http://dask.pydata.org/en/latest/install.html`_</span></a>.</p>
</div>
</div>
</div>
<span id="document-user_manual/overview"></span><div class="section" id="overview-of-supported-em-processes">
<h2>Overview of Supported EM Processes<a class="headerlink" href="#overview-of-supported-em-processes" title="Permalink to this headline">¶</a></h2>
<p>In this section we provide a high-level overview of the EM processes supported by
py_entitymatching. For more details, please read the document “How-To Guide to Entity Matching”
(will soon be available from the package website).</p>
<div class="section" id="supported-em-problem-scenarios">
<h3>Supported EM Problem Scenarios<a class="headerlink" href="#supported-em-problem-scenarios" title="Permalink to this headline">¶</a></h3>
<p>Entity matching (EM) has many problem variations: matching two tables, matching within a
single table, matching from a table into a knowledge base, etc. The package currently only
support matching two tables. Specifically, given two tables A and B of relational tuples,
find all tuple pairs (a in A, b in B) such that a and b refer to the same real-world
entity. The following figure shows an example of matching persons between two given tables.</p>
<a class="reference internal image-reference" href="_images/example-match-two-tables.png"><img alt="'An example of matching two tables'" class="align-center" src="_images/example-match-two-tables.png" style="width: 300.0px; height: 120.0px;" /></a>
<p>Of course, if you want to match tuples within a single table X, you can also use
the package, by matching X with X (you do not have to create another copy of X,
just provide X twice as the input if a command in the package requires two tables A
and B as the input).</p>
</div>
<div class="section" id="two-fundamental-steps-in-the-em-process-blocking-and-matching">
<h3>Two Fundamental Steps in the EM Process: Blocking and Matching<a class="headerlink" href="#two-fundamental-steps-in-the-em-process-blocking-and-matching" title="Permalink to this headline">¶</a></h3>
<p>In practice, tables A and B can be quite large, such as having 100K tuples each, resulting
in 10 billions tuple pairs across A and B. Trying to match all of these pairs is clearly
very expensive. Thus, in such cases the user often employs domain heuristics to quickly
remove obviously non-matched pairs, in a step called <em>blocking</em>, before matching the
remaining pairs, in a step called <em>matching</em>.</p>
<p>The following figure illustrates the above two fundamental steps. Suppose that we are
matching the two tables A and B in (a), where each tuple describes a person. The blocking
step can use a heuristic such as “if two tuples do not agree on state, then they cannot
refer to the same person” to quickly remove all such tuple pairs (this is typically
done using indexes, so the blocking step does not have to enumerate all tuple pairs
between A and B). In other words, the blocking step retains only the four tuple pairs
that agree on state, as shown in (b). The matching step in (c) then considers only these
tuple pairs and predicts for each of them a label “match” or “not-match”
(shown as “+” and “-” in the figure).</p>
<a class="reference internal image-reference" href="_images/example-blocking-matching.png"><img alt="'An example of blocking and matching'" class="align-center" src="_images/example-blocking-matching.png" style="width: 500.0px; height: 220.0px;" /></a>
</div>
<div class="section" id="supported-em-workflows">
<h3>Supported EM Workflows<a class="headerlink" href="#supported-em-workflows" title="Permalink to this headline">¶</a></h3>
<p>The current package supports EM workflows that consist of a blocking step followed by a matching step. Specifically, the package provides a set of blockers and a set of matchers (and the user can easily write his or her own blocker/matcher). Given two tables A and B to be matched, the user applies a blocker to the two tables to obtain a set of tuple pairs, then applies a matcher to these pairs to predict “match” or “no-match”. The user can use multiple blockers in the blocking step, and can combine them in flexible ways. The figure below illustrates both cases.</p>
<a class="reference internal image-reference" href="_images/example-workflow.png"><img alt="'An example of EM workflow'" class="align-center" src="_images/example-workflow.png" style="width: 617.5px; height: 90.25px;" /></a>
<p>Further, the current package supports both rule-based and learning-based matchers. Specifically, rule-based matchers will require the user to write domain specific match rules and learning-based matchers  will require the user to label a set of tuple pairs (as “match” or “no-match”), then use the labeled data to train matchers. In the future, we will consider extending the package to support more powerful EM workflows, such as using multiple matchers, or being able to add rules to process the output of the matchers.</p>
</div>
<div class="section" id="the-development-and-production-stages">
<h3>The Development and Production Stages<a class="headerlink" href="#the-development-and-production-stages" title="Permalink to this headline">¶</a></h3>
<p>In practice EM is typically carried out in two stages. In the development stage, the user tries to find an accurate EM workflow, often using data samples. In the production stage, the user then executes the discovered workflow on the entirety of data. The following figure illustrates the development stage, which is the focus of the current package. The figure also highlights the steps of the development stage that the current package supports.</p>
<p>In the figure, suppose we want to match two tables A and B, each having 1 million tuples. Trying to explore and discover an accurate workflow using these two tables would be too time consuming, because they are too big. Hence, the user will first “down sample” the two tables to obtain two smaller versions, shown as Tables A’ and B’ in the figure, each having 100K tuples, say (see the figure).</p>
<a class="reference internal image-reference" href="_images/example-dev-stage.png"><img alt="'An example of the development stage'" class="align-center" src="_images/example-dev-stage.png" style="width: 500.0px; height: 300.0px;" /></a>
<p>Next, suppose the package provides two blockers X and Y. Then the user will experiment with these blockers (for example, executing both on Tables A’ and B’ and examining their output) to select the blocker judged the best (according to some criterion). Suppose the user selects blocker X. Then next, he or she executes X on Tables A’ and B’ to obtain a set of candidate tuple pairs C.</p>
<p>Next, the user takes a sample S from C, and labels the pairs in S as “match” or “no-match” (see the figure). Let the labeled set be G, and suppose the package provides two matchers U and V. Suppose further that U and V are learning-based matchers (for example, one uses decision trees and the other uses logistic regression). Then in the next step, the user will use the labeled set G to perform cross validation for U and V. Suppose V produces higher matching accuracy (such as F1 score of 0.93, see the figure). Then the user will select V as the matcher, then apply V to the set C to predict “match” or “no-match”, shown as “+” or “-” in the figure. Finally, the user may perform quality check (by examining a sample of the predictions), then go back and debug and modify the previous steps as appropriate. This continues until the user is satisfied with the accuracy of the EM workflow.</p>
<p>Once the user has been satisfied with the EM workflow, the production stage begins. In this stage the user will execute the discovered workflow on the original tables A and B. Since these tables are very large, scaling is a major concern (and is typically solved using Hadoop or Spark). Other concerns include quality monitoring, exception handling, crash recovery, etc.</p>
</div>
<div class="section" id="the-focus-of-the-current-package">
<h3>The Focus of the Current Package<a class="headerlink" href="#the-focus-of-the-current-package" title="Permalink to this headline">¶</a></h3>
<p>The current py_entitymatching package focuses on helping the user with the development stage, that is, help him or her discover an accurate EM workflow. In the future, we will extend the package to also help the user with the production stage.</p>
</div>
</div>
<span id="document-user_manual/guides"></span><div class="section" id="guides">
<h2>Guides<a class="headerlink" href="#guides" title="Permalink to this headline">¶</a></h2>
<p>The goal of this page  is to give you some concrete examples for using py_entitymatching.
These are examples with sample data that is already bundled along with the package. The
examples are in the form of Jupyter notebooks.</p>
<div class="section" id="a-quick-tour-of-jupyter-notebook">
<h3>A Quick Tour of Jupyter Notebook<a class="headerlink" href="#a-quick-tour-of-jupyter-notebook" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://jupyter-notebook-beginner-guide.readthedocs.io/en/latest/index.html">This tutorial</a>
gives a quick tour on installing and using Jupyter notebook.</p>
</div>
<div class="section" id="end-to-end-em-workflows">
<h3>End-to-End EM Workflows<a class="headerlink" href="#end-to-end-em-workflows" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>EM workflow with blocking using a overlap blocker and matching using Random Forest
matcher: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%201.ipynb">Jupyter notebook</a></p></li>
<li><p>EM workflow with blocking using a overlap blocker, selecting among multiple matchers,
using the selected matcher to predict matches, and evaluating the predicted matches: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%202.ipynb">Jupyter notebook</a></p></li>
<li><p>EM workflow with blocking using multiple blockers (overlap and attribute equivalence
blocker), debugging the blocker output, selecting among multiple matchers, debugging the
matcher output, using the selected matcher to predict matches, and evaluating the
predicted matches: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/end_to_end_em_guides/Basic%20EM%20Workflow%20Restaurants%20-%203.ipynb">Jupyter notebook</a></p></li>
</ul>
</div>
<div class="section" id="stepwise-guides">
<h3>Stepwise Guides<a class="headerlink" href="#stepwise-guides" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p>Reading CSV files from disk: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Reading%20CSV%20Files%20from%20Disk.ipynb">Jupyter notebook</a></p></li>
<li><p>Down sampling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Down%20Sampling.ipynb">Jupyter notebook</a></p></li>
<li><p>Data profiling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Data%20Profiling.ipynb">Jupyter notebook</a></p></li>
<li><p>Data exploration: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Data%20Exploration.ipynb">Jupyter notebook</a></p></li>
<li><p>Blocking:</p>
<blockquote>
<div><ul class="simple">
<li><p>Using overlap blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Built-In%20Blockers%20%28Overlap%20Blocker%29.ipynb">Jupyter notebook</a></p></li>
<li><p>Using attribute equivalence blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Built-In%20Blockers%20%28Attr.%20Equivalence%20Blocker%29.ipynb">Jupyter notebook</a></p></li>
<li><p>Using rule-based blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Rule-Based%20Blocking.ipynb">Jupyter notebook</a></p></li>
<li><p>Using blackbox blocker: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Blocking%20Using%20Blackbox%20Blocker.ipynb">Jupyter notebook</a></p></li>
<li><p>Combining multiple blockers: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Combining%20Multiple%20Blockers.ipynb">Jupyter notebook</a></p></li>
<li><p>Debugging blocker output: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Debugging%20Blocker%20Output.ipynb">Jupyter notebook</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Handling features:</p>
<blockquote>
<div><ul class="simple">
<li><p>Generating features manually: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Generating%20Features%20Manually.ipynb">Jupyter notebook</a></p></li>
<li><p>Editing attribute types and generating features manually: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Editing%20and%20Generating%20Features%20Manually.ipynb">Jupyter notebook</a></p></li>
<li><p>Adding features to feature table: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Adding%20Features%20to%20Feature%20Table.ipynb">Jupyter notebook</a></p></li>
<li><p>Removing features from feature table: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Removing%20Features%20From%20Feature%20Table.ipynb">Jupyter notebook</a></p></li>
</ul>
</div></blockquote>
</li>
<li><p>Sampling and labeling: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Sampling%20and%20Labeling.ipynb">Jupyter notebook</a></p></li>
<li><p>Matching:</p>
<blockquote>
<div><ul class="simple">
<li><p>Selecting the best learning-based matcher (involves splitting the labeled data, generating features,
instantiating multiple matchers, debugging the matcher output): <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Selecting%20the%20Best%20Learning%20Matcher.ipynb">Jupyter notebook</a></p></li>
<li><p>Performing matching using rule-based matcher: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Performing%20Matching%20with%20a%20Rule-Based%20Matcher.ipynb">Jupyter notebook</a></p></li>
<li><p>Improving matching results using triggers: <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Using%20Match%20Triggers%20to%20Improve%20Results.ipynb">Jupyter notebook</a></p></li>
<li><p>Evaluating the predictions from a matcher:  <a class="reference external" href="http://nbviewer.jupyter.org/github/anhaidgroup/py_entitymatching/blob/master/notebooks/guides/step_wise_em_guides/Evaluating%20the%20Selected%20Matcher.ipynb">Jupyter notebook</a></p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div>
</div>
<span id="document-user_manual/datastructures"></span><div class="section" id="data-structures">
<h2>Data Structures<a class="headerlink" href="#data-structures" title="Permalink to this headline">¶</a></h2>
<p>In py_entitymatching, we will need to store many tables and metadata associated
with it. It is important for you to know the data structures that are used to store
the tables and the metadata, so that you can manipulate them based on your need.</p>
<p>As a convention, we will use:</p>
<ul class="simple">
<li><p>A and B to refer to the original two tables to be matched,</p></li>
<li><p>C to refer to the candidate set table obtained from A and B after the blocking step,</p></li>
<li><p>S to refer to a sample taken from C, and</p></li>
<li><p>G to refer to a table that contains the tuple pairs in S and a golden label for each
pair (indicating the pair as matches or non-matches).</p></li>
</ul>
<div class="section" id="storing-tables-using-pandas-dataframes">
<h3>Storing Tables Using Pandas Dataframes<a class="headerlink" href="#storing-tables-using-pandas-dataframes" title="Permalink to this headline">¶</a></h3>
<p>We will need to store a lot of data as tables in py_entitymatching. We use pandas Dataframes to
represent tables (you can read more about pandas and pandas Dataframes <a class="reference external" href="http://pandas.pydata.org/">here</a>).</p>
<p><strong>Tuple:</strong> We often refer to a row of a table as tuple. Each tuple is just a row
in a Dataframe and this is of type pandas Series (you can read more about pandas Series
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.Series.html">here</a>).</p>
</div>
<div class="section" id="storing-metadata-using-a-catalog">
<h3>Storing Metadata Using a Catalog<a class="headerlink" href="#storing-metadata-using-a-catalog" title="Permalink to this headline">¶</a></h3>
<p><strong>Bare Minimum that You Should Know:</strong>
In py_entitymatching, we need to store a lot of metadata with a table such as
key and foreign key. We use a
new data structure, Catalog, to store metadata. You need not worry
about instantiating this object (it gets automatically instantiated when py_entitymatching
gets loaded in Python memory) or manipulating this object directly.</p>
<p>All the py_entitymatching commands correctly handle the metadata in the Catalog,
and for you, there are commands to manipulate the Catalog (please see
<a class="reference internal" href="index.html#label-handling-metadata"><span class="std std-ref">Handling Metadata</span></a> section for the supported commands).</p>
<p><strong>If You Want to Read More:</strong>
As we mentioned earlier,  we need to store a lot of metadata with a table. Here are a few examples:</p>
<ul class="simple">
<li><p>Each table in py_entitymatching should have a key, so that we can easily identify the tuples.
Keys are also critical later for debugging, provenance, etc. Key is a metadata that we
want to store for a table.</p></li>
<li><p>The blocking step will create tuple pairs from two tables A and B. For example,
suppose we have table A(aid, a, b) and table B(bid, x, y), then the tuple pairs can be
stored in a candidate set table C(cid, aid, bid, a, b, x, y). This table could be very
big, taking up a lot of space in memory. To save space, we may want to just store C as
C(cid, aid, bid) and then have pointers back to tables A and B. The two pointers back
to A and B are metadata that we may want to store for table C. Specifically, the
metadata for C include key (<cite>cid</cite>) and foreign keys (<cite>aid</cite>, <cite>bid</cite>) to the base tables
(<cite>A</cite>, <cite>B</cite>).</p></li>
</ul>
<p>There are many other examples of metadata that we may want to store for a table. Though
pandas Dataframes is a good choice for storing data as tables, it does not provide a
robust way to store metadata (for more discussion on this topic, please look at <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2485">this thread</a>).
To tackle this, we have a new data structure, <cite>Catalog</cite> to store the metadata for tables.</p>
<p>Conceptually, Catalog is a dictionary, where the keys are unique identifiers for
each Dataframe and the values are dictionaries containing metadata.
This dictionary can have different kinds of keys that point to metadata.
Examples of such keys are:</p>
<ul class="simple">
<li><p>key: the name of the key attribute of the table.</p></li>
<li><p>ltable: pointer to the left table (see below).</p></li>
<li><p>rtable: pointer to the right table (see below).</p></li>
</ul>
<p>The kind of metadata stored for a table would depend on the table itself. For example,
the input tables must have a key and this can be the only metadata.</p>
<p>But, if we consider table C (which is obtained by performing blocking on input tables A
and B), this table can be very large, so we typically represent it using a view over
two tables A and B. Such a table C will have the following attributes:</p>
<ul class="simple">
<li><p>_id (key attribute of table C).</p></li>
<li><p>ltable_aid (aid is the key attribute in table A).</p></li>
<li><p>rtable_bid (bid is the key attribute in table B).</p></li>
<li><p>some attributes from A and B.</p></li>
</ul>
<p>The metadata dictionary for table C will have at least these fields:</p>
<ul class="simple">
<li><p>key: _id.</p></li>
<li><p>ltable: points to table A.</p></li>
<li><p>rtable: points to table B.</p></li>
<li><p>fk_ltable: ltable_aid (that is, ltable.aid is a foreign key of table A).</p></li>
<li><p>fk_rtable: rtable_bid.</p></li>
</ul>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li><p>Tables in py_entitymatching are represented as pandas Dataframes.</p></li>
<li><p>The metadata for tables are stored in a separate data structure called Catalog.</p></li>
<li><p>The kind of metadata stored will depend on the table (for example input table will have key,
and the table from blocking will have key, ltable, rtable, fk_table, fk_rtable).</p></li>
<li><p>So there are five reserved keywords for metadata: key, ltable, rtable, fk_ltable,
fk_rtable. You should not use these names to store metadata for other application
specific purposes.</p></li>
</ul>
</div>
</div>
<span id="document-user_manual/steps_supp_em_workflows"></span><div class="section" id="steps-of-supported-em-workflows">
<h2>Steps of Supported EM Workflows<a class="headerlink" href="#steps-of-supported-em-workflows" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/read_csv_files"></span><div class="section" id="reading-the-csv-files-from-disk">
<h3>Reading the CSV Files from Disk<a class="headerlink" href="#reading-the-csv-files-from-disk" title="Permalink to this headline">¶</a></h3>
<p>Currently, py_entitymatching only asupports reading CSV files from disk.</p>
<p><strong>The Minimal That You Should Do:</strong> First, you must store the input tables as CSV files
in disk. Please look at section <a class="reference internal" href="index.html#label-csv-format"><span class="std std-ref">CSV Format</span></a> to learn more
about CSV format. An example of a CSV file will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">birth_year</span><span class="p">,</span> <span class="n">hourly_wage</span><span class="p">,</span> <span class="n">zipcode</span>
<span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94121</span>
</pre></div>
</div>
<p>Next, each table in py_entitymatching must have a key column. If the table already
has a key column, then you can read the CSV file and set the key column as like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># ID is the key column in table.csv</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>If the table does not have a key column, then you can read the CSV file, add a
key column and set the added key column like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Read the CSV file</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">)</span>
<span class="c1"># Add a key column with name &#39;ID&#39;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">A</span><span class="p">[</span><span class="s1">&#39;ID&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
<span class="c1"># Set &#39;ID&#39; as the key column</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">em</span><span class="o">.</span><span class="n">set_key</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;ID&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><strong>If You Want to Read and Play Around More:</strong> In general, the command
<code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code> looks for a file (with the same file name
as the <cite>CSV</cite> file) with <cite>.metadata</cite> extension in the same directory containing the
metadata. If the file containing metadata information is not present, then
<code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code> will proceed just reading the CSV file
as mentioned in the command.</p>
<p>To update the metadata for a table, using a metadata file, first, you must manually create
this file and specify the metadata for a table and then call
<code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code>. The command will automatically read the metadata from the
file and update the Catalog.</p>
<p>For example, if you read <cite>table.csv</cite> then <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code>
looks for <cite>table.metadata</cite> file. The contents of <cite>table.metadata</cite> may look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#key=ID</span>
</pre></div>
</div>
<p>Each line in the file starts with <cite>#</cite>. The metadata is written as <cite>key=value</cite> pairs,
one in each line. The contents of the above file says that <cite>ID</cite> is the key attribute
(for the table in the file <cite>table.csv</cite>).</p>
<p>The table mentioned in the above example along with the metadata file
stored in the same directory can be read as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Once, the table is read, you can check to see which
attribute of the table is a key using <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_key()</span></code> command as
shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">get_key</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="go">   &#39;ID&#39;</span>
</pre></div>
</div>
<p>As you see, the key for the table is updated correctly as ‘ID’.</p>
<p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code> for more details.</p>
</div>
<span id="document-user_manual/down_sampling"></span><div class="section" id="down-sampling">
<h3>Down Sampling<a class="headerlink" href="#down-sampling" title="Permalink to this headline">¶</a></h3>
<p>Once the tables to be matched are read, they must be down sampled if the number of
tuples in them are large (for example, 100K+ tuples). This is because working with
large tables can be very time consuming (as any operation performed would have
to process these large tables).</p>
<p>Random sampling however does not work, because the sampled may end up sharing very
few matches, especially if the number of matches between the
input tables are small to begin with.</p>
<p>In py_entitymatching, you can use sample the input tables using <cite>down_sample</cite> command.
This command samples the input tables intelligently that ensures a reasonable number of
matches between them.</p>
<p>If <cite>A</cite> and <cite>B</cite> are the input tables, then you can use <cite>down_sample</cite> command as shown
below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sample_A</span><span class="p">,</span> <span class="n">sample_B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">down_sample</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">y_param</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Conceptually, the command takes in two original input tables, <cite>A</cite>, <cite>B</cite> (and some parameters),
and produces two sampled tables, <cite>sample_A</cite> and <cite>sample_B</cite>.
Specifically, you must set the <cite>size</cite> to be the number of tuples that
should be sampled from <cite>B</cite> (this will be the size of <cite>sample_B</cite> table) and set the
<cite>y_param</cite> to be the number of tuples to be selected from <cite>A</cite> (for each tuple in
<cite>sample_B</cite> table). The command internally uses a
heuristic to ensure a reasonable number of matches between <cite>sample_A</cite> and <cite>sample_B</cite>.</p>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">down_sample()</span></code> for more
details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, the input tables must be loaded in memory before the user can down
sample.</p>
</div>
</div>
<span id="document-user_manual/profiling"></span><div class="section" id="profiling-data">
<h3>Profiling Data<a class="headerlink" href="#profiling-data" title="Permalink to this headline">¶</a></h3>
<p>Profiling data is used to help users get general information about their data.
Before working with the data, it is useful for a user to have a high level
understanding of the data because he or she will be able to take advantage of
the the general trends to successfully and efficiently complete the rest of
the workflow.</p>
<p>Data profiling specifically can show users important statistics such as type,
uniqueness, missing values, quartile statistics, mean, mode, standard deviation,
sum, median absolute deviation, coefficient of variation, kurtosis, skewness.
It can also display information to the user visually such as in a histogram.</p>
<p>We recommend using the python package pandas-profiling because it is simple
and easy to use. More information about the package can be found on the github
page at <a class="reference external" href="https://github.com/JosPolfliet/pandas-profiling">https://github.com/JosPolfliet/pandas-profiling</a></p>
<div class="section" id="example-usage">
<h4>Example Usage<a class="headerlink" href="#example-usage" title="Permalink to this headline">¶</a></h4>
<p>After reading in a CSV file into a Dataframe, pandas-profiling shows the user a
report containing useful profiling information. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read in csv file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Use the profiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
<p>The user can also check to see if any variables are highly correlated:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># Read in csv file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1">#Use the profiler</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Check for rejected variables</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rejected_variables</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">get_rejected_variables</span><span class="p">(</span><span class="n">threshold</span><span class="o">=</span><span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
<p>The report generated can also be saved into an html file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pandas_profiling</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save report to a variable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span> <span class="o">=</span> <span class="n">pandas_profiling</span><span class="o">.</span><span class="n">ProfileReport</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save report to an html file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">profile</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">outputfile</span><span class="o">=</span><span class="s2">&quot;/tmp/myoutputfile.html&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information about pandas-profiling please go to the github page
at <a class="reference external" href="https://github.com/JosPolfliet/pandas-profiling">https://github.com/JosPolfliet/pandas-profiling</a></p>
</div>
</div>
<span id="document-user_manual/data_exploration"></span><div class="section" id="data-exploration">
<h3>Data Exploration<a class="headerlink" href="#data-exploration" title="Permalink to this headline">¶</a></h3>
<p>Data exploration is an important part of the entity matching workflow because it
gives the user a chance to look at the actual data closely. Data exploration
allows the user to inspect the individual records and features present in the
table so that he or she can understand the important trends and relationships
present in the data. A complete understanding of the data gives the user an
advantage later on in the entity matching workflow.</p>
<div class="section" id="openrefine">
<h4>OpenRefine<a class="headerlink" href="#openrefine" title="Permalink to this headline">¶</a></h4>
<p>OpenRefine is a data exploration tool that is compatible with Python &gt;= 2.7 or
Python &gt;= 3.4. More information about OpenRefine can be found at its github page
at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine">https://github.com/OpenRefine/OpenRefine</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>OpenRefine is not included with py_entitymatching and must be downloaded and
installed separately. The installation instructions can be found at
<a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions</a></p>
</div>
<div class="section" id="using-openrefine">
<h5>Using OpenRefine<a class="headerlink" href="#using-openrefine" title="Permalink to this headline">¶</a></h5>
<p>Before using OpenRefine, you must start the application to start an OpenRefine
server. The explanations for doing so are explained after the installation
instructions at <a class="reference external" href="https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions">https://github.com/OpenRefine/OpenRefine/wiki/Installation-Instructions</a></p>
<p>Once the application has created a server, copy the URL from the address bar of
the OpenRefine browser (default is <a class="reference external" href="http://127.0.0.1:3333">http://127.0.0.1:3333</a> ). Then the data can
be explored as in the example below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">p</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">data_explore_openrefine</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Table&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Save the project back to our dataframe</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Calling export_pandas_frame will automatically delete the OpenRefine project</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">df</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">export_pandas_frame</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pandastable">
<h4>Pandastable<a class="headerlink" href="#pandastable" title="Permalink to this headline">¶</a></h4>
<p>Pandastable is a data exploration tool available for python &gt;=3.4 that allows users
to view and manipulate data. More information about pandastable can be found at
<a class="reference external" href="https://github.com/dmnfarrell/pandastable">https://github.com/dmnfarrell/pandastable</a></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>pandastable is not packaged along with py_entitymatching. You can install
pandastable using pip as show below:</p>
<blockquote>
<div><p>$ pip install pandastable</p>
</div></blockquote>
<p>or conda as shown below:</p>
<blockquote>
<div><p>$ conda install -c dmnfarrell pandastable=0.7.1</p>
</div></blockquote>
</div>
<div class="section" id="using-pandastable">
<h5>Using pandastable<a class="headerlink" href="#using-pandastable" title="Permalink to this headline">¶</a></h5>
<p>Pandastable can be easily be used with the wrappers included with py_entitymatching.
The following example shows how:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># import py_entitymatching</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Explore the data using pandastable</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">data_explore_pandastable</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<span id="document-user_manual/blocking"></span><div class="section" id="specifying-blockers-and-performing-blocking">
<h3>Specifying Blockers and Performing Blocking<a class="headerlink" href="#specifying-blockers-and-performing-blocking" title="Permalink to this headline">¶</a></h3>
<p>In this section, we discuss how you can specify blockers and perform blocking.</p>
<div class="section" id="types-of-blockers-and-blocker-hierarchy">
<h4>Types of Blockers and Blocker Hierarchy<a class="headerlink" href="#types-of-blockers-and-blocker-hierarchy" title="Permalink to this headline">¶</a></h4>
<p>Once the tables are loaded and downsampled, most often you have to do blocking.
Note that by <em>blocking</em> we mean to block a <em>tuple pair</em> from going through to the
matching step. When applied to a tuple pair, a blocker returns <em>True</em> if the pair
should be blocked. You must know conceptually the types of blockers and
the blocker hierarchy in py_entitymatching to extend or modify them based on your need.</p>
<p>There are two types of blockers: (1) tuple-level, and (2) global. A tuple-level blocker
can examine a tuple pair in isolation and decide if it should be admitted to the next
stage. For example, an attribute equivalence blocker is a tuple-level blocker. A global
blocker cannot make this decision in isolation. It would need to examine a set of other
pairs as well. For example, a sorted neighborhood blocker applied over an union of the
input tables is a global blocker. Currently, py_entitymatching supports only
tuple-level blockers.</p>
<p>The blockers can be combined in complex ways, such as</p>
<ul class="simple">
<li><p>apply blocker <em>b1</em> to the two tables</p></li>
<li><p>apply blocker <em>b2</em> to the two tables</p></li>
<li><p>apply blocker <em>b3</em> to the output of <em>b1</em></p></li>
</ul>
<p>Further, you may just want to apply a blocker to just a pair of tuples, to see how
the blocker works.</p>
<p>In py_entitymatching, there is a Blocker class from which a set of concrete blockers
are inherited. These concrete blockers implement the following methods:</p>
<ul class="simple">
<li><p>block_tables (apply to input tables A and B)</p></li>
<li><p>block_candset (apply to an output from another blocker (e.g. table C))</p></li>
<li><p>block_tuples (apply to a tuple pair to check if it will survive blocking)</p></li>
</ul>
<p>In py_entitymatching, there are four concrete blockers implemented: (1) attribute
equivalence blocker, (2) overlap blocker, (3) rule-based blocker, and (4) black box
blocker. All the functions implemented in the concrete blockers are metadata aware.</p>
<p>The class diagram of Blocker and the concrete blockers inherited from it is shown below:</p>
<a class="reference internal image-reference" href="_images/blocker_hierarchy.png"><img alt="'Blocker Hierarchy'" src="_images/blocker_hierarchy.png" style="width: 1162.0px; height: 259.0px;" /></a>
</div>
<div class="section" id="built-in-blockers">
<h4>Built-In Blockers<a class="headerlink" href="#built-in-blockers" title="Permalink to this headline">¶</a></h4>
<p>Built-in blockers are those that have been built into py_entitymatching and you can just
simply call them. <em>py_entitymatching</em> currently offers three built-in blockers.</p>
<p><strong>Attribute Equivalence Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in attribute equivalence blocker
takes an attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that
is, drop the tuple pair) if <cite>x</cite> and <cite>y</cite> are not of the same value.</p>
<p>An example of using the above function is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>. An example of using
<cite>block_candset</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code>
for more details.</p>
<p><strong>Overlap Blocker</strong></p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> in overlap blocker takes an
attribute <cite>x</cite> of table A, an attribute <cite>y</cite> of table B, and returns True (that is, drop
the tuple pair) if <cite>x</cite> and <cite>y</cite> do not share any token (where the token is a word or
a q-gram).</p>
<p>As part of the pre-processing for this blocker, the strings are first converted to lowercase.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">,</span> <span class="s1">&#39;age&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code>
for more details.</p>
<p><strong>Sorted Neighborhood Blocker</strong></p>
<p>WARNING: THIS IS AN EXPERIMENTAL COMMAND. THIS COMMAND IS NOT TESTED. USE AT YOUR OWN RISK.</p>
<p>Given two tables A and B, conceptually, <cite>block_tables</cite> works in the following manner.
First, for table A, <cite>block_tables</cite> creates a blocking attribute for every tuple using the output of <cite>l_block_attr</cite>.
Next, for table B, <cite>block_tables</cite> similarly creates a blocking attribute using the output of <cite>r_block_attr</cite>.
Then, tables A and B are combined and sorted on the blocking attribute.</p>
<p>Finally, a sliding window of size <cite>window_size</cite> is passed through the sorted dataset.
If two tuples are within <cite>window_size</cite> positions of each other in sorted order, and the two tuples
come from different tables, then the two tuples are returned in the candidate set.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">A</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_A.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">read_csv_metadata</span><span class="p">(</span><span class="s1">&#39;path_to_csv_dir/table_B.csv&#39;</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sn</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">SortedNeighborhoodBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">sn</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_block_attr</span><span class="o">=</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">r_block_attr</span><span class="o">=</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">3</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>Unlike the other two blockers, since the sorted neighborhood blocker requires the sorted order
of all tuples in the database, <cite>block_candset</cite> and <cite>block_tuples</cite> are not applicable and will raise an assertion if called.</p>
<p>Two things to note.
First, consider the trade-off of possible values to <cite>window_size</cite>.
If the size is too small, actually-matching tuples will not be returned in the candidate set (and thus, missed).
If the window size is very large, the resulting candidate set will also be excessively large, hurting performance.
The exact size needed is unique to each dataset.</p>
<p>Second, if <cite>window_size</cite> is smaller than a range of matching tuples, and actually-matching tuples will be missed, not be returned in the candidate set.
However, if the blocking attribute is not sufficient to make a unique sorted order, than the resulting sorted order is one of a set of potential sorted orders.
If the method of sorting changes, for instance if more cores are used, a different sorted order may be returned.
This sorted order may result in a different candidate set being returned.
To avoid this situation it is recommended to add some uniqueness into the blocking attribute (such as the ID), so that there is only one correct sorted order.
This will help ensure the same set of results are returned from the same inputs.
An example of this is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;birth_year_plus_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;birth_year&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">B</span><span class="p">[</span><span class="s2">&quot;birth_year_plus_id&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">B</span><span class="p">[</span><span class="s2">&quot;birth_year&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;-&#39;</span><span class="o">+</span><span class="n">A</span><span class="p">[</span><span class="s2">&quot;ID&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C3</span> <span class="o">=</span> <span class="n">sn</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_block_attr</span><span class="o">=</span><span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="n">r_block_attr</span><span class="o">=</span><span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year_plus_id&#39;</span><span class="p">,</span> <span class="s1">&#39;birth_year&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">],</span> <span class="n">l_output_prefix</span><span class="o">=</span><span class="s1">&#39;l_&#39;</span><span class="p">,</span> <span class="n">r_output_prefix</span><span class="o">=</span><span class="s1">&#39;r_&#39;</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>In this example a new attribute <cite>birth_year_plus_id</cite> is used as the blocking attribute, and will always have the same sorted order.</p>
</div>
<div class="section" id="blackbox-blockers">
<h4>Blackbox Blockers<a class="headerlink" href="#blackbox-blockers" title="Permalink to this headline">¶</a></h4>
<p>By <cite>blackbox blockers</cite> we mean that the user supplies a Python function which
encodes blocking for a tuple pair. Specifically, the Python function will take
in two tuples and returns True if the tuple pair needs to be blocked, else
returns False. To use a blackbox blocker, first you must write a
blackbox blocker function.</p>
<p>An example of blackbox blocker function is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">match_last_name</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that there is a &#39;name&#39; attribute in the input tables</span>
    <span class="c1"># and each value in it has two words</span>
    <span class="n">l_last_name</span> <span class="o">=</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">r_last_name</span> <span class="o">=</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">l_last_name</span> <span class="o">!=</span> <span class="n">r_last_name</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<p>Then instantiate a <cite>blackbox blocker</cite> and set the blocking function function as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BlackBoxBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bb</span><span class="o">.</span><span class="n">set_black_box_function</span><span class="p">(</span><span class="n">match_last_name</span><span class="p">)</span>
</pre></div>
</div>
<p>Now, you can call <cite>block_tables</cite> on the input tables. Conceptually, <cite>block_tables</cite> would
apply the blackbox blocker function on the Cartesian product of the input tables A and B, and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code>
for more details.</p>
<p>Further, <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">bb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code>
for more details.</p>
</div>
<div class="section" id="rule-based-blockers">
<h4>Rule-Based Blockers<a class="headerlink" href="#rule-based-blockers" title="Permalink to this headline">¶</a></h4>
<p>You can write a few domain specific rules (for blocking purposes) using rule-based blocker.
If you want to write rules, then you must start by defining a set of features.
Each <cite>feature</cite> is a function that when applied to a tuple pair will return a
numeric value. We will discuss how to create a set of features in the section
<a class="reference internal" href="index.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>block_f</cite>. Then you will be able
to instantiate a rule-based blocker and add rules like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>block_f</cite> is a set of features stored as a Dataframe (see section
<a class="reference internal" href="index.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The blocker is then a disjunction of rules.
That is, even if one of the rules return True, then the tuple pair will be blocked.</p>
<p>Once the rules are specified, you can call <cite>block_tables</cite> on the input tables.
Conceptually, <cite>block_tables</cite> would
apply the rule-based blocker function on the Cartesian product of the input tables A and B and
return a candidate set of tuple pairs.</p>
<p>An example of using <cite>block_tables</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span> <span class="n">r_output_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tables()</span></code>
for more details.</p>
<p>The function <cite>block_candset</cite> is similar to <cite>block_tables</cite> except <cite>block_candset</cite> is
applied to the candidate set, i.e. the output from <cite>block_tables</cite>.</p>
<p>An example of using <cite>block_candset</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_candset()</span></code>
for more details.</p>
<p>The function <cite>block_tuples</cite> is used to check if a tuple pair would get blocked. An
example of using <cite>block_tuples</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tuples</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">status</span>
<span class="go">    True</span>
</pre></div>
</div>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">block_tuples()</span></code>
for more details.</p>
</div>
<div class="section" id="combining-multiple-blockers">
<h4>Combining Multiple Blockers<a class="headerlink" href="#combining-multiple-blockers" title="Permalink to this headline">¶</a></h4>
<p>If you use multiple blockers, then you have to combine them to get a
consolidated candidate set. There are many different ways to combine the candidate sets
such as doing union, majority vote, weighted vote, etc. Currently, py_entitymatching
only supports union-based combining.</p>
<p>In py_entitymatching, <cite>combine_blocker_outputs_via_union</cite> is used to do union-based
combining.</p>
<p>An example of using <cite>combine_blocker_outputs_via_union</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ab</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">AttrEquivalenceBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ab</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_candset</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">E</span> <span class="o">=</span> <span class="n">rb</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">F</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">combine_blocker_outputs_via_union</span><span class="p">([</span><span class="n">C</span><span class="p">,</span> <span class="n">E</span><span class="p">])</span>
</pre></div>
</div>
<p>Conceptually, the command takes in a list of blocker outputs (i.e. pandas Dataframes) and
produces a consolidated table. The output table contains the union of tuple pair ids and
other attributes from the input list.</p>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">combine_blocker_outputs_via_union()</span></code>
for more details.</p>
</div>
</div>
<span id="document-user_manual/create_feats_for_blocking"></span><div class="section" id="creating-features-for-blocking">
<span id="label-create-features-blocking"></span><h3>Creating Features for Blocking<a class="headerlink" href="#creating-features-for-blocking" title="Permalink to this headline">¶</a></h3>
<p>Recall that when doing blocking, you can use built-in blockers,
blackbox blockers, or rule-based blockers. For rule-based blockers,
you have to create a set of features. While creating features, you will have to
refer to tokenizers, similarity functions, and attributes of the tables.
Currently, in py_entitymatching, there are two ways to create features:</p>
<ul class="simple">
<li><p>Automatically generate a set of features (then you can remove or add some more).</p></li>
<li><p>Skip the automatic process and generate features manually.</p></li>
</ul>
<p>Note that features will also be used in the matching process, as we
will discuss later.</p>
<p>If you are interested in just letting the system to automatically
generate a set of features, then please see <a class="reference internal" href="#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a>.</p>
<p>If you want to generate features on your own, please read below.</p>
<div class="section" id="available-tokenizers-and-similarity-functions">
<h4>Available Tokenizers and Similarity Functions<a class="headerlink" href="#available-tokenizers-and-similarity-functions" title="Permalink to this headline">¶</a></h4>
<p>A tokenizer is a function that takes a string and optionally a number
of other arguments, then tokenizes the string and returns a set of tokens.
Currently, the following tokenizers are provided along with <em>py_entitytmatching</em>:</p>
<ul class="simple">
<li><p>Alphabetic</p></li>
<li><p>Alphanumeric</p></li>
<li><p>White space</p></li>
<li><p>Delimiter based</p></li>
<li><p>Qgram based</p></li>
</ul>
<p>A similarity function takes two arguments (can be strings, numeric values, etc.),
which are typically two attribute values such
as two book titles, then returns an output value which is typically a similarity score
between the two attribute values. Currently, the following similarity functions
are provided along with <em>py_entitytmatching</em>:</p>
<ul class="simple">
<li><p>Affine</p></li>
<li><p>Hamming distance</p></li>
<li><p>Jaro</p></li>
<li><p>Jaro-Winkler</p></li>
<li><p>Levenshtein</p></li>
<li><p>Monge-Elkan</p></li>
<li><p>Needleman-Wunsch</p></li>
<li><p>Smith-Waterman</p></li>
<li><p>Jaccard</p></li>
<li><p>Cosine</p></li>
<li><p>Dice</p></li>
<li><p>Overlap coefficient</p></li>
<li><p>Exact match</p></li>
<li><p>Absolute norm</p></li>
</ul>
</div>
<div class="section" id="obtaining-tokenizers-and-similarity-functions">
<h4>Obtaining Tokenizers and Similarity Functions<a class="headerlink" href="#obtaining-tokenizers-and-similarity-functions" title="Permalink to this headline">¶</a></h4>
<p>First you need to get tokenizers and similarity functions to refer them in features.
In py_entitymatching, you can use
<cite>get_tokenizers_for_blocking</cite> to get all the tokenizers available for blocking purposes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above, <cite>block_t</cite> is a dictionary where keys are tokenizer names
and values are tokenizer functions in Python. You can inspect <cite>block_t</cite> and delete/add
tokenizers as appropriate. The above command will return single-argument tokenizers,
i.e., those that take a string then produce a set of tokens.</p>
<p>Each of the keys of the default dictionary returned to ‘block_t’ by
‘get_tokenizers_for_blocking’ represent a tokenizer that can be used by similarity
functions. The keys and the respective tokenizer they represent are shown below:</p>
<ul class="simple">
<li><p>alphabetic: Alphabetic tokenizer</p></li>
<li><p>alphanumeric: Alphanumeric tokenizer</p></li>
<li><p>dlm_dc0: Delimiter tokenizer using spaces as the delimiter</p></li>
<li><p>qgm_2: Two Gram tokenizer</p></li>
<li><p>qgm_3: Three Gram tokenizer</p></li>
<li><p>wspace: Whitespace tokenizer</p></li>
</ul>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_tokenizers_for_blocking()</span></code>
for more details.</p>
<p>Similarly, the user can use <cite>get_sim_funs_for_blocking</cite> to get all the similarity
functions available for blocking purposes.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
</pre></div>
</div>
<p>In the above, <cite>block_s</cite> is a dictionary where keys are similarity function names
and values are similarity functions in Python. Similar to <cite>block_t</cite>, you can
inspect <cite>block_s</cite> and delete/add similarity functions as appropriate.</p>
<p>Each of the keys of the default dictionary returned to ‘block_s’ by
‘get_sim_funs_for_blocking’ represent a similarity function. The keys and the
respective similarity function they represent are shown below:</p>
<ul class="simple">
<li><p>abs_norm: Absolute Norm</p></li>
<li><p>affine: Affine Transformation</p></li>
<li><p>cosine: Cosine Similarity</p></li>
<li><p>dice: Dice similarity Coefficient</p></li>
<li><p>exact_match: Exact Match</p></li>
<li><p>hamming_dist: Hamming Distance</p></li>
<li><p>hamming_sim: Hamming Similarity</p></li>
<li><p>jaccard: Jaccard Similarity</p></li>
<li><p>jaro: Jaro Distance</p></li>
<li><p>jaro_winkler: Jaro-Winkler Distance</p></li>
<li><p>lev_dist: Levenshtein Distance</p></li>
<li><p>lev_sim: Levenshtein Similarity</p></li>
<li><p>monge_elkan: Monge-Elkan Algorithm</p></li>
<li><p>needleman_wunsch: Needleman-Wunsch Algorithm</p></li>
<li><p>overlap_coeff: Overlap Coefficient</p></li>
<li><p>rel_diff: Relative Difference</p></li>
<li><p>smith_waterman: Smith-Waterman Algorithm</p></li>
</ul>
<p>Please look at the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_sim_funs_for_blocking()</span></code>
for more details.</p>
</div>
<div class="section" id="obtaining-attribute-types-and-correspondences">
<h4>Obtaining Attribute Types and Correspondences<a class="headerlink" href="#obtaining-attribute-types-and-correspondences" title="Permalink to this headline">¶</a></h4>
<p>In the next step, you need to obtain type and correspondence information about A and B
so that the features can be generated.</p>
<p>First, you need to obtain the types of attributes in A and B,
so that the right tokenizers/similarity functions can be applied to each of them.
In py_entitymatching, you can use <cite>get_attr_types</cite> to get the attribute types.
An example of using <cite>get_attr_types</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>atypes1</cite> and <cite>atypes2</cite> are dictionaries. They contain, the type of
attribute in each of the tables. Note that this <cite>type</cite> is different from basic
Python types. Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_attr_types()</span></code> for more details.</p>
<p>Next, we need to obtain correspondences between the attributes of A and B,
so that the features can be generated based on those correspondences.
In py_entitymatching, you can use <cite>get_attr_corres</cite> to get the attribute
correspondences.</p>
<p>An example of using <cite>get_attr_corres</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>block_c</cite> is a dictionary containing attribute correspondences.
Currently, py_entitymatching returns attribute correspondences only based on the exact
match of attribute names. You can inspect <cite>block_c</cite> and modify the attribute
correspondences. Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_attr_corres()</span></code> for more details.</p>
</div>
<div class="section" id="getting-a-set-of-features">
<span id="label-get-a-set-of-features-manual"></span><h4>Getting a Set of Features<a class="headerlink" href="#getting-a-set-of-features" title="Permalink to this headline">¶</a></h4>
<p>Recall that so far we have obtained:</p>
<ul class="simple">
<li><p>block_t, the set of tokenizers,</p></li>
<li><p>block_s, the set of sim functions</p></li>
<li><p>atypes1 and atypes2, the types of attributes in A and B</p></li>
<li><p>block_c, the correspondences of attributes in A and B</p></li>
</ul>
<p>Next, to obtain a set of features, you can use <cite>get_features</cite> command.
An example of using <cite>get_features</cite> command is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Briefly, this function will go through the correspondences. For each
correspondence <cite>m</cite>, it examines the types of the involved attributes,
then apply the appropriate tokenizers and similarity functions to generate
all appropriate features for this correspondence. The features are returned as
a Dataframe. Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_features()</span></code> for more details.</p>
</div>
<div class="section" id="adding-removing-features">
<span id="label-add-remove-features"></span><h4>Adding/Removing Features<a class="headerlink" href="#adding-removing-features" title="Permalink to this headline">¶</a></h4>
<p>Given the set of features <cite>block_f</cite> as a pandas Dataframe, you can delete certain features,
add new features.</p>
<p>Deletion of a feature is straightforward, all that you have to do is delete the row
from the feature table corresponding to the feature. You can use <cite>drop</cite> command
from pandas Dataframe for this purpose. Please look at this
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.drop.html">API reference link</a>
for more details.</p>
<p>There are two ways to create and add a feature: (1) write a blackbox function and
add it to feature table, and (2) define a feature declartively and add it to
feature table.</p>
<p><strong>Adding a Blackbox Function as Feature</strong></p>
<p>To create and add a blackbox function as a feature, first you must define it. Specifically,
the function must take in two tuples as input and return a numeric value. An example of
a blackbox function is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
    <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Then add it to the feature table <cite>block_f</cite> using <cite>add_blackbox_feature</cite> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">add_blackbox_feature()</span></code> for more details.</p>
<p><strong>Adding a Feature Declaratively</strong></p>
<p>Another way to add features is to write a feature expression in
a <cite>declarative</cite> way. py_entitymatching will then compile it into a feature. For
example, you can declaratively create and add a feature like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple[&quot;name&quot;]), qgm_3(rtuple[&quot;name&quot;]))&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>Here <cite>block_t</cite> and <cite>block_s</cite> refer to the dictionaries containing a set of
tokenizers and similarity functions for blocking. Additionally, ‘jaccard’ refers
to the key in ‘block_s’ that represents the Jaccard Similarity function and
‘qgm_3’ refers to the key in ‘block_t’ that represents a three gram tokenizer.
The keys in ‘block_t’ and ‘block_s’ and which function or tokenizer they
represent are explained above in the Obtaining Tokenizers and Similarity Functions
section.</p>
<p>Conceptually, the first command, <cite>get_feature_fn</cite>, creates a feature which is a Python function
that will take two tuples <cite>ltuple</cite> and <cite>rtuple</cite>, get the attribute publisher from <cite>ltuple</cite>,
issuer from <cite>rtuple</cite>, tokenize them, then compute jaccard score.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The feature must refer the tuple from the left table (say A) as <strong>ltuple</strong> and
the tuple from the right table (say B) as <strong>rtuple</strong>.</p>
</div>
<p>The second command, <cite>add_feature</cite> tags the feature with the specified name,
and adds it to the feature table.</p>
<p>As described, the feature that was just created is <em>independent</em> of any table
(eg A and B). Instead, it expects as the input two tuples: ltuple and rtuple.</p>
<p>You can also create more complex features. Specifically,
you are allowed to define arbitrary complex expression involving function names from
<cite>block_t</cite> and <cite>block_s</cite>, and attribute names from ltuple and rtuple.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.address + ltuple.zipcode), qgm_3(rtuple.address + rtuple.zipcode)&#39;</span><span class="p">,</span><span class="n">block_t</span><span class="p">,</span><span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;full_address_address_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also create your own similarity functions and tokenizers for your custom features.
For example, you can create a similarity function that changes all strings to lowercase
before checking if they are equivalent.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This similarity function converts the two strings to lowercase before checking if they are an exact match</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">match_lowercase</span><span class="p">(</span><span class="n">l_attr</span><span class="p">,</span> <span class="n">r_attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">l_attr</span> <span class="o">=</span> <span class="n">l_attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">r_attr</span> <span class="o">=</span> <span class="n">r_attr</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">else</span><span class="p">:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="k">return</span> <span class="mi">0</span>
</pre></div>
</div>
<p>You can then add a feature declarativly with your new similarity function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The new similarity function is added to block_s and then a new feature is created</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span><span class="p">[</span><span class="s1">&#39;match_lowercase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">match_lowercase</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;match_lowercase(ltuple[&quot;name&quot;], rtuple[&quot;name&quot;])&#39;</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_match_lowercase&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>It is also possible to create features with your own similarity functions that require
tokenizers. The next example shows how to create a custom tokenizer that returns only
the first and last words of a string.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This custom tokenizer returns the first and last words of a string</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first_last_tok</span><span class="p">(</span><span class="n">attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">all_toks</span> <span class="o">=</span> <span class="n">attr</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">toks</span> <span class="o">=</span> <span class="p">[</span><span class="n">all_toks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_toks</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">all_toks</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">toks</span>
</pre></div>
</div>
<p>Next, a similarity function that can utilize the new tokenizer is created. This example
shows how to create a similarity function that raises the score if the first words match
and raises the score by one if the second words match.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># This similarity function compares two tokens from each set.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># Greater weight is placed on the equality of the first token.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">first_last_sim</span><span class="p">(</span><span class="n">l_attr</span><span class="p">,</span> <span class="n">r_attr</span><span class="p">):</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">score</span> <span class="o">+=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">if</span> <span class="n">l_attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">r_attr</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
<span class="gp">&gt;&gt;&gt; </span>        <span class="n">score</span> <span class="o">+=</span><span class="mi">1</span>
<span class="gp">&gt;&gt;&gt; </span>    <span class="k">return</span> <span class="n">score</span>
</pre></div>
</div>
<p>Finally, with the tokenizer and similarity functions defined, the new feature can be
created and added.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># The new tokenizer is added to block_t and the new similarity function is added to block_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># then a new feature is created</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span><span class="p">[</span><span class="s1">&#39;first_last_tok&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_last_tok</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span><span class="p">[</span><span class="s1">&#39;first_last_sim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">first_last_sim</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;first_last_sim(first_last_tok(ltuple[&quot;name&quot;]), first_last_tok(rtuple[&quot;name&quot;]))&#39;</span><span class="p">,</span>
<span class="gp">&gt;&gt;&gt; </span>                 <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;name_name_fls_flt_flt&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
<p>Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_feature_fn()</span></code> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">add_feature()</span></code>
for more details.</p>
</div>
<div class="section" id="summary-of-the-manual-feature-generation-process">
<h4>Summary of the Manual Feature Generation Process<a class="headerlink" href="#summary-of-the-manual-feature-generation-process" title="Permalink to this headline">¶</a></h4>
<p>Here is the summary of commands for the entire manual feature generation process.</p>
<p>To generate features, you must execute the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_blocking</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>The variable <cite>block_f</cite> points to a Dataframe containing features as rows.</p>
</div>
<div class="section" id="ways-to-edit-the-manual-feature-generation-process">
<h4>Ways to Edit the Manual Feature Generation Process<a class="headerlink" href="#ways-to-edit-the-manual-feature-generation-process" title="Permalink to this headline">¶</a></h4>
<p>Here is the summary of ways to edit the variables used in feature generation process.</p>
<ul>
<li><p>The <cite>block_t</cite>, <cite>block_s</cite>, <cite>atypes1</cite>, <cite>atypes2</cite>, <cite>block_c</cite> are dictionaries. You
can modify these variables based on your need, to add/remove tokenizers,
similarity functions, attribute correspondences, etc.</p></li>
<li><p><cite>block_f</cite> is a Dataframe. You can remove a feature by just deleting the corresponding
tuple from the Dataframe.</p></li>
<li><p>There are two ways to create and add a feature: (1) write a blackbox function and
add it to feature table, and (2) define the feature declartively and add it to
feature table.
To add a blackbox feature, first write a blackbox function like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">age_diff</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">):</span>
    <span class="c1"># assume that the tuples have age attribute and values are valid numbers.</span>
    <span class="k">return</span> <span class="n">ltuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rtuple</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Then add it to the table <cite>block_f</cite> using <cite>add_blackbox_feature</cite> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">status</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">add_blackbox_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;age_difference&#39;</span><span class="p">,</span> <span class="n">age_diff</span><span class="p">)</span>
</pre></div>
</div>
<p>To add a feature declaratively, first write a feature expression and compile it to feature
using <cite>get_feature_fn</cite> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_feature_fn</span><span class="p">(</span><span class="s1">&#39;jaccard(qgm_3(ltuple.address + ltuple.zipcode), qgm_3(rtuple.address + rtuple.zipcode)&#39;</span><span class="p">,</span><span class="n">block_t</span><span class="p">,</span><span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Then add it to the table <cite>block_f</cite> using <cite>add_feature</cite> like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">add_feature</span><span class="p">(</span><span class="n">block_f</span><span class="p">,</span> <span class="s1">&#39;full_address_address_jac_qgm3_qgm3&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ul>
</div>
<div class="section" id="generating-features-automatically">
<span id="label-gen-feats-automatically"></span><h4>Generating Features Automatically<a class="headerlink" href="#generating-features-automatically" title="Permalink to this headline">¶</a></h4>
<p>Recall that to get the features for blocking, eventually you
must execute the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atypes2</span><span class="p">,</span> <span class="n">block_c</span><span class="p">,</span> <span class="n">block_t</span><span class="p">,</span> <span class="n">block_s</span><span class="p">)</span>
</pre></div>
</div>
<p>where <cite>atypes1</cite>/<cite>atypes2</cite> are the attribute types of A and B, <cite>block_c</cite> is
the correspondences between their attributes, <cite>block_t</cite> is the set of tokenizers,
and <cite>block_s</cite> is the set of similarity functions.</p>
<p>If you don’t want to go through the hassle of creating these intermediate
variables, then you can execute the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>The system will automatically generate a set of features and return it as
as a Dataframe which you can then use for blocking purposes. This Dataframe
contains a few attributes that require further explanation, specifically
‘left_attr_tokenizer’, ‘right_attr_tokenizer’, and ‘simfunction’. There are
two types of similarity functions, those that use tokenizers and those that
do not. Some similarity functions use tokenizers and all such features must
designate a tokenizer for both the left table attribute in
‘left_attr_tokenizer’ and for the right table attribute in
‘right_attr_tokenizer’. The ‘simfunction’ attribute refers to the name of
the function and comes from the keys in ‘block_s’. The various keys and the
actual functions they correspond to are explained in the Obtaining
Tokenizers and Similarity Functions section above.</p>
<p>The command <cite>get_features_for_blocking</cite> will set the following variables: <cite>_block_t</cite>,
<cite>_block_s</cite>, <cite>_atypes1</cite>, <cite>_atypes2</cite>, and <cite>_block_c</cite>. You can access these variables like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_block_c</span>
</pre></div>
</div>
<p>You can examine these variables, modify them as appropriate, and
then perhaps re-generate the set of features using <cite>get_features</cite> command.</p>
<p>Please look at the API reference of
<code class="xref py py-meth docutils literal notranslate"><span class="pre">get_features_for_blocking()</span></code> for more details.</p>
</div>
</div>
<span id="document-user_manual/debugging_blocking"></span><div class="section" id="debugging-blocking">
<h3>Debugging Blocking<a class="headerlink" href="#debugging-blocking" title="Permalink to this headline">¶</a></h3>
<p>In a typical entity matching workflow, you will load in the two tables to
match, sample them (if required) and use a blocker to remove obvious non-matches.
But it is often not clear whether the blocker drops only non-matches or it
also removes a lot of potential matches.</p>
<p>In such cases, it is important to debug the output of blocker. In
py_entitymatching, <cite>debug_blocker</cite> command can be used for that purpose.</p>
<p>The <cite>debug_blocker</cite> command takes in two input tables A, B, blocker output C
and returns a table D containing a set of tuple pairs that are
potential matches and yet are not present in the blocker output
C. Table D also contains similarity measure computed for each reported
tuple pair (as its second column).</p>
<p>You can examine these potential matches in table D. If you
find that many of them are indeed true matches, then that means the
blocker may have removed too many true matches. In this case you
may want to <cite>relax</cite> the blocker by modifying its parameters, or
choose a different blocker. On the other hand, if you do not
find many true matches in table D, then it could be the case that the
blocker has done a good job and preserve all the matches (or most of
the matches) in the blocker output C.</p>
<p>In the <cite>debug_blocker</cite>, you can optionally specify attribute correspondences between
the input tables A and B. If it is not specified, then attribute correspondences
will be a list of attribute pairs with the exact same names in A and B.</p>
<p>The debugger will use only the attributes mentioned in these attribute
correspondences to try to find potentially matching pairs and place
those pairs into D. Thus, our recommendation is that (a) if the tables
have idential schemas or share a lot of attributes with the same
names, then do not specify the attribute correspondences, in this
case the debugger will use all the attributes with the same name between the two
schemas, (b) otherwise think about what attribute pairs you want to see the
debugger use, then specify those as attribute correspondences.</p>
<p>An example of using <cite>debug_blocker</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">py_entitymatching</span> <span class="k">as</span> <span class="nn">em</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ob</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">OverlapBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">block_tables</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">l_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">r_overlap_attr</span><span class="o">=</span><span class="s1">&#39;title&#39;</span><span class="p">,</span> <span class="n">overlap_size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corres</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span><span class="s1">&#39;ssn&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="s1">&#39;ename&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;address&#39;</span><span class="p">,</span> <span class="s1">&#39;location&#39;</span><span class="p">),(</span><span class="s1">&#39;zipcode&#39;</span><span class="p">,</span> <span class="s1">&#39;zipcode&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">D</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">debug_blocker</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">attr_corres</span><span class="o">=</span><span class="n">corres</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">debug_blocker()</span></code>
for more details.</p>
<p>The blocker debugger is implemented in Cython. In case this version of the
command is not working properly, there is also a python version of the command,
called <cite>backup_debug_blocker</cite>, available that can be used instead. Please refer
to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">backup_debug_blocker()</span></code> for
more details.</p>
</div>
<span id="document-user_manual/sampling"></span><div class="section" id="sampling">
<span id="label-sampling"></span><h3>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h3>
<p>If you have to use supervised learning-based matchers or evaluate matchers, you need to
create labeled data. To create labeled data, first you need to sample of candidate set
pairs and then label them.</p>
<p>In <em>py_stringmatching</em>, you can use <cite>sample_table</cite> to get a sample. The command does
uniform random sampling without replacement. An example of using <cite>sample_table</cite> is shown
below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">sample_table</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>The command will first create a copy of the input table, sample the specified number of
tuple pairs from the copy, update the metadata and return the sampled table.</p>
<p>For more details, please look into the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">sample_table()</span></code></p>
</div>
<span id="document-user_manual/labeling"></span><div class="section" id="labeling">
<h3>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h3>
<p>The command <cite>label_table</cite> can be used to label the samples (see section
<a class="reference internal" href="index.html#label-sampling"><span class="std std-ref">Sampling</span></a>). An example of using <cite>label_table</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">label_table</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">label_column_name</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above command will first create a copy of the input table <cite>S</cite>, update
the metadata, add a column with the
specified column name (in <cite>label_col_name</cite> parameter) fill it with 0 (i.e non-matches)
and open a GUI for you to update the labels. You must specify 0 for non-matches and
1 for matches. Once you close the GUI, the updated table will be returned.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">label_table()</span></code>
for more details.</p>
</div>
<span id="document-user_manual/split_train_test"></span><div class="section" id="splitting-labeled-data-into-training-and-testing-sets">
<h3>Splitting Labeled Data into Training and Testing Sets<a class="headerlink" href="#splitting-labeled-data-into-training-and-testing-sets" title="Permalink to this headline">¶</a></h3>
<p>While doing entity matching you will have to split data for
multiple purposes. Some examples are:</p>
<p>1. Split labeled data into development and test. Th development
set is used to come up with right features for learning-based matcher, and
<cite>test</cite> set is used to evaluate the matcher.</p>
<p>2. Split feature vectors into a train and test set. The train
set is used to train the learning-based matcher and test set is used
for evaluation.</p>
<p>py_entitymatching provides <cite>split_train_test</cite> command for the above need.
An example of using <cite>split_train_test</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">train_proportion</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>split_train_test</cite> returns a dictionary with two keys: train, and test.
The value for the key <cite>train</cite> is a Dataframe containing tuples
allocated from the input table based on train_proportion.
Similarly, the value for the key <cite>test</cite> is a Dataframe containing
tuples for evaluation. An example of getting train and test Dataframes from the output
of <cite>split_train_test</cite> command is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">devel_set</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_set</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>Setting the value for train proportion would depend on the
context of its use. For instance, if the data is split for machine learning
purposes then train proportion is typically larger than the
test.
The most commonly used values of train_proportion are between
0.5 and 0.8.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">split_train_test()</span></code> for
more details.</p>
</div>
<span id="document-user_manual/create_feats_for_matching"></span><div class="section" id="creating-features-for-matching">
<span id="label-create-feats-matching"></span><h3>Creating Features for Matching<a class="headerlink" href="#creating-features-for-matching" title="Permalink to this headline">¶</a></h3>
<p>If you have to use supervised learning-based matchers, then you cannot just operate on the
labeled set of tuple pairs. For each tuple in the labeled, you need to convert it
into a feature vector which consists of a list of numerical/categorical features. To do
this, first we need to create a set of features.</p>
<p>There are two ways to create features:</p>
<ul class="simple">
<li><p>Automatically create a set of features (then the user can remove or add some more).</p></li>
<li><p>Skip the automatic process and generate features manually.</p></li>
</ul>
<div class="section" id="creating-the-features-manually">
<h4>Creating the Features Manually<a class="headerlink" href="#creating-the-features-manually" title="Permalink to this headline">¶</a></h4>
<p>This is very similar to manual feature creation process for blocking (see section
<a class="reference internal" href="index.html#label-create-features-blocking"><span class="std std-ref">Creating Features for Blocking</span></a>) except the features are created for
matching purposes.
In brief, you can execute the following sequence of commands in py_entitymatching
to create the features manually:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_t</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_tokenizers_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_s</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_sim_funs_for_matching</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes1</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes1 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atypes2</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_types</span><span class="p">(</span><span class="n">B</span><span class="p">)</span> <span class="c1"># don&#39;t need, if atypes2 exists from blocking step</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_c</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_attr_corres</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">atypes1</span><span class="p">,</span> <span class="n">atype2</span><span class="p">,</span> <span class="n">match_c</span><span class="p">,</span> <span class="n">match_t</span><span class="p">,</span> <span class="n">match_s</span><span class="p">)</span>
</pre></div>
</div>
<p>Further, you can add or delete features as see saw in section
<a class="reference internal" href="index.html#label-add-remove-features"><span class="std std-ref">Adding/Removing Features</span></a>.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_tokenizers_for_matching()</span></code>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">py_entitymatching.get_sim_funs_for_matching()</span></code> for more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Currently, py_entitymatching returns the same set of features for blocking and matching purposes.</p>
</div>
</div>
<div class="section" id="creating-the-features-automatically">
<h4>Creating the Features Automatically<a class="headerlink" href="#creating-the-features-automatically" title="Permalink to this headline">¶</a></h4>
<p>If you do not want to go through the hassle of creating the features manually, then
the user can generate the features automatically. This is very similar to automatic
feature creation process for blocking (see section <a class="reference internal" href="index.html#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a>).</p>
<p>In py_entitymatching, you can use <cite>get_features_for_matching</cite> to generate features
for matching purposes automatically. An example of using <cite>get_features_for_matching</cite> is
shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">match_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_matching</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>Similar to what we saw in section <a class="reference internal" href="index.html#label-gen-feats-automatically"><span class="std std-ref">Generating Features Automatically</span></a> for blocking, the
command will set the following variables: <cite>_match_t</cite>, <cite>_match_s</cite>, <cite>_atypes1</cite>, <cite>_atypes2</cite>, <cite>_match_c</cite>
and they can be accessed like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_t</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_s</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_atypes2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">_match_c</span>
</pre></div>
</div>
<p>You can to examine these variables, modify them as appropriate, and then
perhaps regenerate a set of features.
Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">get_features_for_matching()</span></code>
for more details.</p>
</div>
</div>
<span id="document-user_manual/extract_feat_vecs"></span><div class="section" id="extracting-feature-vectors">
<h3>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h3>
<p>Once you have created a set of features, you use them to convert labeled sample to feature
vectors. In py_entitymatching, you can use <cite>extract_feature_vecs</cite> to convert
labeled sample to feature vectors using the features created
(see section <a class="reference internal" href="index.html#label-create-feats-matching"><span class="std std-ref">Creating Features for Matching</span></a>).</p>
<p>An example of using <cite>extract_feature_vecs</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feature_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feature_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_before</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;title&#39;</span><span class="p">],</span> <span class="n">attrs_after</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>Conceptually, the command takes the labeled data (<cite>G</cite>), applies the feature functions (in <cite>match_f</cite>)
to each tuple in G to create a Dataframe, adds the <cite>attrs_before</cite> and <cite>attrs_after</cite>
columns, updates the metadata and returns the resulting Dataframe.</p>
<p>If there is one (or several columns) in labeled data that contains the labels, then those need
to be explicitly specified in <cite>attrs_after</cite>, if you want them them to copy over.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">extract_feature_vecs()</span></code>
for more details.</p>
</div>
<span id="document-user_manual/imputing_missing_values"></span><div class="section" id="imputing-missing-values">
<h3>Imputing Missing Values<a class="headerlink" href="#imputing-missing-values" title="Permalink to this headline">¶</a></h3>
<p>While doing supoervised learning-based matching, you would need to create labeled sample,
convert the sample into table of feature vectors, fill in the missing values, select
a machine learning (ML) model and use it to produce matches.</p>
<p>The step of filling in the missing values (also called imputing
missing values) is important and necessary. If there are missing values in the input
tables A and B, then they would be passed on to candidate set and most
likely to the feature vectors. In py_entitymatching, if the feature vectors
contain missing values, then most of the ML algorithms would not work
as they rely on scikit-learn package to provide ML-algorithm
implementations (and their implementations would not work if the
feature vectors contain NaN’s).</p>
<p>To avoid missing value problem in the feature vectors, you must impute the values
of the NaN’s. There are many different ways to impute missing values such as
filling the NaN’s (in the whole table or just some columns) with a constant value,
or fill the NaN’s with an aggregate value (mean, median, etc.).</p>
<p>Since the table is represented as a pandas Dataframe, there are two common ways to impute
missing values: (1) use <cite>fillna</cite> method from pandas Dataframe, and (2) impute missing
values using <cite>Imputer</cite> from Scikit-learn package.</p>
<p>But there are two problems that we have to tackle if we have to using the above commands
or objects directly:</p>
<ul class="simple">
<li><p>They are not metadata aware, so the user has to explicitly take care of it.</p></li>
<li><p>The Dataframe type that gets imputed typically contains attributes such as key, foreign
keys to A and B. The user must have to rightly project them out to impute missing
values using aggregates.</p></li>
</ul>
<p>In py_entitymatching, we propose a hybrid method to impute missing values. To fill NaN’s
with a constant value use <cite>fillna</cite> command from pandas Dataframe. Please look at the
<a class="reference external" href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.fillna.html">API reference of fillna</a>
for more details. An example of using <cite>fillna</cite> to the whole table is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>H</cite> is a Dataframe containing feature vectors, 0 is the constant value that
to be filled in, and <cite>inplace=True</cite> means that the updation should be done in place
(i.e., without creating a copy). It is important to set <cite>inplace=True</cite> as we do not want
the metadata for H in Catalog to be corrupted.</p>
<p>Another example of using <cite>fillna</cite> on a column is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span><span class="p">[</span><span class="s1">&#39;name_name_lev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="s1">&#39;name_name_lev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that, in the above <cite>inplace</cite> should be specified as False, this is because
the output is getting assigned to a column in the old Dataframe <cite>H</cite> and the metadata
of <cite>H</cite> does not get affected.</p>
<p>To fill NaN’s with an aggregate value, in py_entitymatching you can use <cite>impute_table</cite>
command. It is a wrapper around scikit-learn’s <cite>Imputer</cite> object (to make it metadata aware).
An example of using <cite>impute_table</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">impute_table</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">strategy</span><span class="o">=</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If all the values in a column or a row are NaN’s, then the above aggregation
strategy will not work (i.e. we cannot compute the mean and use it to fill the
missing values). In such cases, you need to specify a value in <cite>val_all_nans</cite>
parameter and the command will use this value to fill in all the missing values.</p>
</div>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">impute_table()</span></code> for
more details.</p>
</div>
<span id="document-user_manual/matching"></span><div class="section" id="specifying-matchers-and-performing-matching">
<h3>Specifying Matchers and Performing Matching<a class="headerlink" href="#specifying-matchers-and-performing-matching" title="Permalink to this headline">¶</a></h3>
<div class="section" id="ml-matchers">
<h4>ML-Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h4>
<p>Once yor convert the labeled sample  into a table of feature vectors (and their
labels), the we can  can create and apply matchers to the feature vectors.
Currently py_entitymatching supports only ML-based matchers. Implementation wise,
a Matcher is defined as a Python class with certain methods (and some common
utility functions) and all concrete blockers inherit from this Matcher class and
override the methods. Specifically, each concrete matcher will implement at least
the following methods:</p>
<ul class="simple">
<li><p>fit (for training)</p></li>
<li><p>predict (for prediction)</p></li>
</ul>
<div class="section" id="creating-learning-based-matchers">
<h5>Creating Learning-Based Matchers<a class="headerlink" href="#creating-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>In py_entitymatching, there are seven concrete ML-matchers implemented: (1) naive bayes,
(2) logistic regression, (3) linear regression, (4) support vector machine, (5) decision
trees, (6) random forest, and (7) xgboost matcher.</p>
<p>These concrete matchers are just wrappers of scikit-learn matchers or that supports
scikit-learn wrappers (for eg., xgboost) and this is because
the fit/predict methods in scikit-learn are not metadata aware. The concrete matchers
make the scikit-learn matchers metadata aware.</p>
<p>Each matcher can be created by calling its constructor. Since these matchers are
just the wrappers of scikit-learn matchers, the parameters that can be given to
scikit-learn matchers can be to given to the matchers in py_entitymatching.
For example, a user can create a Decision Tree matcher like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to <code class="xref py py-meth docutils literal notranslate"><span class="pre">DTMatcher()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">RFMatcher()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">NBMatcher()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">LogisticRegressionMatcher()</span></code>,
<code class="xref py py-meth docutils literal notranslate"><span class="pre">LinearRegressionMatcher()</span></code>, <code class="xref py py-meth docutils literal notranslate"><span class="pre">SVMMatcher()</span></code>, and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">XGBoostMatcher()</span></code>
for more details.</p>
</div>
<div class="section" id="training-learning-based-matchers">
<h5>Training Learning-Based Matchers<a class="headerlink" href="#training-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>Once the ML-matcher is instantiated, you can train the matcher using the
<cite>fit</cite> command. An example of using the <cite>fit</cite> command for Decision Tree matcher
is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>There are other variants of <cite>fit</cite> method. As an example, Please refer to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">fit()</span></code> for more details.</p>
</div>
<div class="section" id="applying-learning-based-matchers">
<h5>Applying Learning-Based Matchers<a class="headerlink" href="#applying-learning-based-matchers" title="Permalink to this headline">¶</a></h5>
<p>Once the ML-matcher is trained, you can predict the matches using the
<cite>predict</cite> command. An example of using the <cite>predict</cite> command for Decision Tree matcher
is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">return_probs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">probs_attr</span><span class="o">=</span><span class="s1">&#39;proba&#39;</span><span class="p">,</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="go">inplace=True)</span>
</pre></div>
</div>
<p>There are other variants of <cite>predict</cite> method. As an example, Please refer to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">predict()</span></code> for more details.</p>
</div>
</div>
<div class="section" id="rule-based-matchers">
<h4>Rule-Based Matchers<a class="headerlink" href="#rule-based-matchers" title="Permalink to this headline">¶</a></h4>
<p>You can write a few domain specific rules (for matching purposes) using the rule-based
matcher. If you want to write rules, then you must start by defining a set of features.
Each <cite>feature</cite> is a function that when applied to a tuple pair will return a
numeric value. We will discuss how to create a set of features in the section
<span class="xref std std-ref">label-create-features-matching</span>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>match_f</cite>. Then you will be able
to instantiate a rule-based matcher and add rules.</p>
<div class="section" id="adding-and-deleting-rules">
<h5>Adding and Deleting Rules<a class="headerlink" href="#adding-and-deleting-rules" title="Permalink to this headline">¶</a></h5>
<p>Once you have created the features for matching, you can create rules like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">BooleanRuleMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>match_f</cite> is a set of features stored as a Dataframe (see section
<span class="xref std std-ref">label-create-features-matching</span>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The matcher is then a disjunction of rules.
That is, even if one of the rules return True, then the tuple pair will be a match.</p>
<p>Rules can also be deleted once they have been added to the matcher:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rule_name</span> <span class="o">=</span> <span class="n">brm</span><span class="o">.</span><span class="n">add_rule</span><span class="p">(</span><span class="n">rule_1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="n">rule_name</span><span class="p">)</span>
</pre></div>
</div>
<p>The command delete_rule must be given the name of the rule to be deleted. Rule names
and information on rules in a matcher can be found using the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get a list of rule names</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule_names</span> <span class="o">=</span> <span class="n">brm</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view rule source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get rule fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">get_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="applying-rule-based-matcher">
<h5>Applying Rule-Based Matcher<a class="headerlink" href="#applying-rule-based-matcher" title="Permalink to this headline">¶</a></h5>
<p>Once the rules are specified, you can predict the matches using the
<cite>predict</cite> command. An example of using the <cite>predict</cite> command is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">brm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information on the <cite>predict</cite> method, please refer to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">predict()</span></code> for more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/select_best_matcher"></span><div class="section" id="selecting-a-ml-matcher">
<h3>Selecting a ML-Matcher<a class="headerlink" href="#selecting-a-ml-matcher" title="Permalink to this headline">¶</a></h3>
<p>Once you have created different concrete ML matchers, then you have to choose one of
them for matching purposes. There are many different criteria by which one can
decide to choose a matcher such as <cite>akaike information criterion</cite>, <cite>bayesian information
criterion</cite>, <cite>k-fold cross validation</cite>, etc. Currently py_entitymatching supports
k-fold cross validation and other approaches are left for future work.</p>
<p>Conceptually, the command to select a matcher would take in the following inputs:</p>
<ul class="simple">
<li><p>List of ML matchers.</p></li>
<li><p>Training data (feature vector).</p></li>
<li><p>A column of labels that correspond to the feature vectors in the training data.</p></li>
<li><p>Number of folds.</p></li>
</ul>
<p>And it would produce the following output:</p>
<ul class="simple">
<li><p>Selected matcher.</p></li>
<li><p>Statistics such as mean accuracy of all input matchers.</p></li>
</ul>
<p>In py_entitymatching, <cite>select_matcher</cite> command addresses the above needs. An
example of using <cite>select_matcher</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">select_matcher</span><span class="p">(</span><span class="n">matchers</span><span class="o">=</span><span class="p">[</span><span class="n">dt</span><span class="p">,</span> <span class="n">rf</span><span class="p">],</span> <span class="n">table</span><span class="o">=</span><span class="n">train</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above the output, <cite>result</cite> is a dictionary containing three keys: (1) selected_matcher,
(2) cv_stats, and (3) drill_down_cv_stats. <cite>selected_matcher</cite> is the selected ML-based matcher,
<cite>cv_stats</cite> is a Dataframe which includes the average cross validation scores for each matcher
and for each metric, and ‘drill_down_cv_stats’ is a dictionary where each key is a metric that
includes the cross validation statistics for each fold.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">select_matcher()</span></code> for
more details.</p>
</div>
<span id="document-user_manual/debugging_matcher"></span><div class="section" id="debugging-ml-matchers">
<h3>Debugging ML-Matchers<a class="headerlink" href="#debugging-ml-matchers" title="Permalink to this headline">¶</a></h3>
<p>While doing entity matching you would like to choose a matcher that produces the desired
precision, recall or F1 numbers. If a matcher does not produce the desired accuracy, then
you would like to debug the matcher. py_entitymatching supports two ways to
debug: (1) using the GUI, and (2) using the command line.</p>
<div class="section" id="debugging-using-the-gui">
<h4>Debugging Using the GUI<a class="headerlink" href="#debugging-using-the-gui" title="Permalink to this headline">¶</a></h4>
<p>py_entitymatching supports debugging using the GUI for a subset of ML-based matchers.
Specifically, it supports debugging Decision Tree matcher and Random Forest matcher.
You can use <cite>vis_debug_dt</cite> and <cite>vis_debug_rf</cite> to debug Decision Tree matcher
and Random Forest matcher respectively.</p>
<p>An example of using <cite>vis_debug_dt</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train_test</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">split_train_test</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="o">=</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;train&#39;</span><span class="p">],</span> <span class="n">train_test</span><span class="p">[</span><span class="s1">&#39;test&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">vis_debug_dt</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The command would display a GUI containing evaluation summary and an option to see tuples
flagged as <cite>false positives</cite> or <cite>false negatives</cite>. If you select <cite>false positives</cite>
then false positive tuple pairs would be displayed in the adjoining window. Similarly,
if <cite>false negatives</cite> is selected then false negative tuple pairs would be
displayed. By default, <cite>false positives</cite> is selected.
Each tuple pair is displayed with two buttons: <cite>show</cite> and <cite>debug</cite>. If you click on
<cite>show</cite>, then individual tuples (of that tuple pair) are displayed in a separate window.
If you click on <cite>debug</cite>, then a window with individual tuples and the
path taken by the feature vector in the Decision Tree that leads to the predicted value
is displayed.</p>
<p>The usage of <cite>vis_debug_rf</cite> is same as <cite>vis_debug_dt</cite>. The command would display a GUI
similar to <cite>vis_debug_dt</cite>, except the debug window would list a set of trees. You can
expand each tree to see the path taken by the features in that tree.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">vis_debug_dt()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">vis_debug_rf()</span></code> for more details.</p>
<p>If you want to debug a Decision Tree matcher or Random Forest matcher using GUI,
then we recommend the following steps:</p>
<ol class="arabic simple">
<li><p>In the displayed GUI, check precision and recall numbers in evaluation summary.</p></li>
<li><p>If the user wants to improve precision, then he/she should choose to see false positives.</p></li>
<li><p>If the user wants to improve recall, then he/she should choose to see false negatives.</p></li>
<li><p>In the displayed (false positive/false negative) tuple pairs,
you can click on the <cite>show</cite> button to see the tuples from the left and right tables.</p></li>
<li><p>In the displayed (false positive/false negative) tuple pairs, you can choose a tuple
and click on the <cite>debug</cite> button to see the detailed evaluation path of that tuple.</p></li>
<li><p>Based on the input tuples, predicates at each node and the actual feature value,
you should decide on the next step. Some of the possible next steps are
cleaning  the input data, adding more features, adding more training data, trying a
different matcher, etc.</p></li>
</ol>
</div>
<div class="section" id="debugging-using-the-command-line">
<h4>Debugging Using the Command Line<a class="headerlink" href="#debugging-using-the-command-line" title="Permalink to this headline">¶</a></h4>
<p>Similar to debugging using the GUI, py_entitymatching supports command line debugging for two
ML matchers: Decision Tree and Random Forest. Currently, py_entitymatching  supports
command line debugging only using tuple pairs, other approaches are left for future work.</p>
<p>You can use <cite>debug_decisiontree_matcher</cite> and <cite>debug_randomforest_matcher</cite> to debug
Decision Tree matcher and Random Forest matcher respectively.</p>
<p>An example of using <cite>debug_decisiontree_matcher</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">devel</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">F</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">debug_decisiontree_matcher</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">match_f</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, the debug command prints the path taken by the feature vector, its
evaluation status at each node and the actual feature value at each node.</p>
<p>The usage of <cite>debug_randomforest_matcher</cite> is same as <cite>debug_decisiontree_matcher</cite>.
Similar to <cite>debug_decisiontree_matcher</cite> command, it prints the path taken by the feature
vector, except that it displays the path taken in each tree of the Random Forest.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">debug_decisiontree_matcher()</span></code>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">debug_randomforest_matcher()</span></code> for more details.</p>
<p>If you want to debug a Decision Tree matcher or Random
Forest matcher using the command line, then we recommend the following steps:</p>
<ol class="arabic simple">
<li><p>Evaluate the accuracy of predictions using user created labels. The evaluation can
be done using <code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_matches()</span></code> command.</p></li>
<li><p>If you want to improve precision, then he/she should debug false positives.</p></li>
<li><p>If you want to improve recall, then he/she should debug false negatives.</p></li>
<li><p>You should then retrieve the tuples from the tuple id pairs listed in evaluation
summary, and debug using the commands described above.</p></li>
<li><p>Based on the input tuples, predicates at each node and the actual feature value,
you should decide on the next step. Some of the possible next steps are clean
the input data, add more features, add more training data, try different matcher, etc.</p></li>
</ol>
</div>
<div class="section" id="impact-of-imputing-missing-values">
<h4>Impact of Imputing Missing Values<a class="headerlink" href="#impact-of-imputing-missing-values" title="Permalink to this headline">¶</a></h4>
<p>You should be aware of the following subtleties as it would
have an impact when he/she imputes values to feature vector set:</p>
<p>1. When you use the GUI for debugging, you would first choose to see
false positives/false negatives and then you would click the <cite>debug</cite> button to debug
that tuple pair. In this case, the feature vector in that row is given as input to find the path
traversed in the Decision Tree. If you had imputed the feature vector set to get
rid of NaN’s, then the imputed values would be considered to find the path traversed.</p>
<p>2. When you use the command line for debugging, then you would first evaluate the
predictions, select false positive or false negative tuple pairs to debug, retrieve the
tuples from the left and right tables and finally give them as input to command line
debugger commands. If you had imputed the feature vector set to get rid of NaN’s (using
a aggregate strategy), then imputed values would not be known to the debugger.</p>
<p>So if the input tables have NaN’s, then the output of the command line debugger would only
be partially correct (i.e., the displayed predicates would be correct, but the predicate
outcome may differ between current tuple pair and the actual feature vector used during
prediction).</p>
</div>
</div>
<span id="document-user_manual/matchercombiner"></span><div class="section" id="combining-predictions-from-multiple-matchers">
<h3>Combining Predictions from Multiple Matchers<a class="headerlink" href="#combining-predictions-from-multiple-matchers" title="Permalink to this headline">¶</a></h3>
<p>In the matching step, if you use multiple matchers then you will have to combine the
predictions from them to get a consolidated prediction. There are many different ways
to combine these predictions such as weighted vote, majority vote, stacking, etc.
Currently, py_entitymatching supports majority and weighted voting-based combining.
These combiners are experimental and not tested.</p>
<p>An example of using majority voting-based combining is shown below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span> <span class="o">=</span> <span class="n">NBMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># H is training set containing feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">)</span> <span class="c1"># L is the test set for which we should get predictions.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;rf_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;nb_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mv_combiner</span> <span class="o">=</span> <span class="n">MajorityVote</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;consol_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mv_combiner</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">L</span><span class="p">[[</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;rf_predictions&#39;</span><span class="p">,</span> <span class="s1">&#39;nb_predictions&#39;</span><span class="p">]])</span>
</pre></div>
</div>
<p>Conceptually, given a list of predictions (from different matchers) the prediction that
occurs most is returned as the consolidated prediction. If there is no clear winning
prediction (for example, 0 and 1 occuring equal number of times) then 0 is returned.</p>
<p>An example of using weighted voting-based combining is shown below.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span> <span class="o">=</span> <span class="n">RFMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span> <span class="o">=</span> <span class="n">NBMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span> <span class="c1"># H is training set containing feature vectors</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">)</span> <span class="c1"># L is the test set for which we should get predictions.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rf</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;rf_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;label&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nb</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">L</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="s1">&#39;l_id&#39;</span><span class="p">,</span> <span class="s1">&#39;r_id&#39;</span><span class="p">],</span> <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;nb_predictions&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">wv_combiner</span> <span class="o">=</span> <span class="n">WeightedVote</span><span class="p">(</span><span class="n">weights</span><span class="o">=</span><span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="n">threshold</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">L</span><span class="p">[</span><span class="s1">&#39;consol_predictions&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wv_combiner</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">L</span><span class="p">[[</span><span class="s1">&#39;dt_predictions&#39;</span><span class="p">,</span>
<span class="go">&#39;rf_predictions&#39;, &#39;nb_predictions&#39;]])</span>
</pre></div>
</div>
<p>Conceptually, given a list of predictions, each prediction is given a
weight, we compute a weighted sum of these predictions and compare the result to a
threshold. If the result is greater than or equal to the threshold then the
consolidated prediction is returned as 1 (i.e., a match) else returned as 0 (no-match).</p>
</div>
<span id="document-user_manual/triggers"></span><div class="section" id="using-triggers-to-update-matching-results">
<h3>Using Triggers to Update Matching Results<a class="headerlink" href="#using-triggers-to-update-matching-results" title="Permalink to this headline">¶</a></h3>
<div class="section" id="match-triggers">
<h4>Match Triggers<a class="headerlink" href="#match-triggers" title="Permalink to this headline">¶</a></h4>
<p>Once you have used a matcher to predict results on a table, you might find
that there is some pattern of false positives or false negatives. Often, it
is useful to be able to create a set of rules to reevaluate tuple pair
predictions to correct these patterns of mistakes.</p>
<div class="section" id="creating-the-trigger">
<h5>Creating the Trigger<a class="headerlink" href="#creating-the-trigger" title="Permalink to this headline">¶</a></h5>
<p>Each trigger can be created by calling its constructor. For example, a user can
create a trigger like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
</pre></div>
</div>
<p>Please refer to <code class="xref py py-meth docutils literal notranslate"><span class="pre">MatchTrigger()</span></code> for more details.</p>
<p>If you have already used a matcher, you should have already created a set of features
for matching. More information on this can be found in the section
<span class="xref std std-ref">label-create-features-matching</span>.</p>
<p>Once the features are created, py_entitymatching stores this set of features in a
feature table. We refer to this feature table as <cite>match_f</cite>. Then you will be able
to instantiate a match trigger and add rules.</p>
</div>
<div class="section" id="adding-and-deleting-rules">
<h5>Adding and Deleting Rules<a class="headerlink" href="#adding-and-deleting-rules" title="Permalink to this headline">¶</a></h5>
<p>Once you have created the features, you can create rules like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">MatchTrigger</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule2</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>match_f</cite> is a set of features stored as a Dataframe (see section
<span class="xref std std-ref">label-create-features-matching</span>).</p>
<p>Each rule is a list of strings. Each string specifies a conjunction of predicates. Each
predicate has three parts: (1) an expression, (2) a comparison operator, and (3) a
value. The expression is evaluated over a tuple pair, producing a numeric value.
Currently, in py_entitymatching an expression is limited to contain a single feature
(being applied to a tuple pair). So an example predicate will look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span>
</pre></div>
</div>
<p>In the above <cite>name_name_lev</cite> is feature. Concretely, this feature computes
Levenshtein distance between the <cite>name</cite> values in the input tuple pair.</p>
<p>As an example, the rules <cite>rule1</cite> and <cite>rule2</cite> can look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rule1</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;name_name_lev(ltuple, rtuple) &gt; 3&#39;</span><span class="p">,</span> <span class="s1">&#39;age_age_exact_match(ltuple, rtuple) !=0&#39;</span><span class="p">]</span>
<span class="n">rule2</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;address_address_lev(ltuple, rtuple) &gt; 6&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>In the above, <cite>rule1</cite> contains two predicates and <cite>rule2</cite> contains just a single
predicate. Each rule is a conjunction of predicates. That is, each rule will return True
only if all the predicates return True. The matcher is then a disjunction of rules.
That is, even if one of the rules return True, then the result for the tuple pair will
be true.</p>
<p>You also need to add a condition status and action when using match triggers. If the
result is the same value as the condition status, then the action will be carried out.
For example, the action and condition status can be declared like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_cond_status</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">add_action</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>The condition status and action in the above example mean that if the rules in the
trigger return the value False, then the prediction will be changed to a 0.</p>
<p>Rules can also be deleted once they have been added:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rule_name</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">add_cond_rule</span><span class="p">(</span><span class="n">rule_1</span><span class="p">,</span> <span class="n">match_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">delete_rule</span><span class="p">(</span><span class="n">rule_name</span><span class="p">)</span>
</pre></div>
</div>
<p>The command delete_rule must be given the name of the rule to be deleted. Rule names
and information on rules can be found using the following commands:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># get a list of rule names</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rule_names</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">get_rule_names</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># view rule source</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">view_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># get rule fn</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">get_rule</span><span class="p">(</span><span class="s1">&#39;rule_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="executing-the-triggers">
<h5>Executing the Triggers<a class="headerlink" href="#executing-the-triggers" title="Permalink to this headline">¶</a></h5>
<p>Once the rules, condition status, and action have been specified, the trigger can be
used to refine the predictions. An example of using the execute command is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mt</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">input_table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">label_column</span><span class="o">=</span><span class="s1">&#39;prediction_labels&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<p>For more information on the <cite>execute</cite> method, please refer to
<code class="xref py py-meth docutils literal notranslate"><span class="pre">execute()</span></code> for more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/evaluate_matching"></span><div class="section" id="evaluating-the-matching-output">
<h3>Evaluating the Matching Output<a class="headerlink" href="#evaluating-the-matching-output" title="Permalink to this headline">¶</a></h3>
<p>Once you have predicted matches using ML-based matcher, then you would have to
evaluate the matches. py_entitymatching supports <cite>eval_matches</cite> command for that
purpose.</p>
<p>An example of using <cite>eval_matches</cite> command is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">extract_feat_vecs</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">feat_table</span><span class="o">=</span><span class="n">match_f</span><span class="p">,</span> <span class="n">attrs_after</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">DTMatcher</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span> <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;gold_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pred_table</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="n">H</span><span class="p">,</span>  <span class="n">exclude_attrs</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">,</span> <span class="s1">&#39;ltable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;rtable_id&#39;</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">],</span>  <span class="n">append</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">target_attr</span><span class="o">=</span><span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eval_summary</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">eval_matches</span><span class="p">(</span><span class="n">pred_table</span><span class="p">,</span> <span class="s1">&#39;gold_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;predicted_labels&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above, <cite>eval_summary</cite> is a dictionary containing accuracy numbers (such as
precision, recall, F1, etc) and the list of false positives/negatives.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">eval_matches()</span></code> for
more details.</p>
</div>
</div>
</div>
<span id="document-user_manual/misc"></span><div class="section" id="miscellaneous">
<h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<p>This section covers some miscellaneous things in py_entitymatching.</p>
<div class="section" id="csv-format">
<span id="label-csv-format"></span><h3>CSV Format<a class="headerlink" href="#csv-format" title="Permalink to this headline">¶</a></h3>
<p>The CSV format is selected because it’s well known and can be read by numerous external
programs. Further, it can be easily inspected and edited by the users.
You can read more about CSV formats <a class="reference external" href="https://en.wikipedia.org/wiki/Comma-separated_values">here</a>.</p>
<p>There are two common CSV formats that are used to store CSV files: one with attribute
names in the first line, and one without. Both these formats are supported by py_entitymatching.</p>
<p>An example of a CSV file with attribute names is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ID</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">birth_year</span><span class="p">,</span> <span class="n">hourly_wage</span><span class="p">,</span> <span class="n">zipcode</span>
<span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94321</span>
</pre></div>
</div>
<p>An example of a CSV file with out attribute names is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">a1</span><span class="p">,</span> <span class="n">Kevin</span> <span class="n">Smith</span><span class="p">,</span> <span class="mi">1989</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">94107</span>
<span class="n">a2</span><span class="p">,</span> <span class="n">Michael</span> <span class="n">Franklin</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mf">27.5</span><span class="p">,</span> <span class="mi">94122</span>
<span class="n">a3</span><span class="p">,</span> <span class="n">William</span> <span class="n">Bridge</span><span class="p">,</span> <span class="mi">1988</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">94321</span>
</pre></div>
</div>
</div>
<div class="section" id="metadata-file-format">
<h3>Metadata File Format<a class="headerlink" href="#metadata-file-format" title="Permalink to this headline">¶</a></h3>
<p>The CSV file can be accompanied with a metadata file containing the metadata information
of the table. Typically, it contains information such as key, foreign key, etc.
The metadata file is expected to be of the same name as the CSV file but with <cite>.metadata</cite>
extension. For example, if the CSV file <cite>table_A.csv</cite> contains table A’s data, then
<cite>table_A.metadata</cite> will contain table A’s metadata. So, the metadata is
associated based on the names of the files. The metadata file contains key-value pairs
one per line and each line starts with ‘#’.</p>
<p>An example of metadata file is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#key=ID</span>
</pre></div>
</div>
<p>In the above, the pair key=ID states that ID is the key attribute.</p>
</div>
<div class="section" id="writing-a-dataframe-to-disk-along-with-its-metadata">
<h3>Writing a Dataframe to Disk Along With Its Metadata<a class="headerlink" href="#writing-a-dataframe-to-disk-along-with-its-metadata" title="Permalink to this headline">¶</a></h3>
<p>To write a Dataframe to disk along with its metadata, you can use <cite>to_csv_metadata</cite>
command in py_entitymatching. An example of using <cite>to_csv_metadata</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">to_csv_metadata</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;./table_A.csv&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above command will first write Dataframe pointed by <cite>A</cite> to <cite>table_A.csv</cite> file in the
disk (in CSV format), next it will write the metadata of <cite>table A</cite> stored in the Catalog
to <cite>table_A.metadata</cite> file in the disk.</p>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">to_csv_metadata()</span></code> for
more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Once the Dataframe is written to disk along with metadata, it can read using <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_csv_metadata()</span></code> command.</p>
</div>
</div>
<div class="section" id="writing-reading-other-types-of-py-entitymatching-objects">
<h3>Writing/Reading Other Types of py_entitymatching Objects<a class="headerlink" href="#writing-reading-other-types-of-py-entitymatching-objects" title="Permalink to this headline">¶</a></h3>
<p>After creating a blocker or feature table, it is desirable to have a
way to persist the objects to disk for future use. py_entitymatching provides
two commands for that purpose: <cite>save_object</cite> and <cite>load_object</cite>.</p>
<p>An example of using <cite>save_object</cite> is shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">block_f</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">get_features_for_blocking</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">RuleBasedBlocker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span><span class="o">.</span><span class="n">add_rule</span><span class="p">([</span><span class="n">name_name_lev</span><span class="p">(</span><span class="n">ltuple</span><span class="p">,</span> <span class="n">rtuple</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">],</span> <span class="n">block_f</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">em</span><span class="o">.</span><span class="n">save_object</span><span class="p">(</span><span class="n">rb</span><span class="p">,</span> <span class="s1">&#39;./rule_based_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><cite>load_object</cite> loads the stored object from disk. An example of using <cite>load_object</cite> is
shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">rb</span> <span class="o">=</span> <span class="n">em</span><span class="o">.</span><span class="n">load_object</span><span class="p">(</span><span class="s1">&#39;./rule_based_blocker.pkl&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Please refer to the API reference of <code class="xref py py-meth docutils literal notranslate"><span class="pre">save_object()</span></code> and
<code class="xref py py-meth docutils literal notranslate"><span class="pre">save_object()</span></code> for more details.</p>
</div>
</div>
</div>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/overview"></span><div class="section" id="overview-of-command-organization">
<h2>Overview of Command Organization<a class="headerlink" href="#overview-of-command-organization" title="Permalink to this headline">¶</a></h2>
<p>The commands are organized into two parts. First, the commands that the user will typically use to
create an entity matching workflow. Second, a set of experimental commands that are expected to be
useful to create an entity matching workflow. Specifically, it includes commands  such
as  dask-based implementations for blockers and combining predictions from a set of matchers.
However, the experimental commands are not tested, so use these commands at your own risk.</p>
</div>
<span id="document-user_manual/api/actual_commands"></span><div class="section" id="commands-in-py-entitymatching">
<h2>Commands in py_entitymatching<a class="headerlink" href="#commands-in-py-entitymatching" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/reading_and_writing_data"></span><div class="section" id="reading-and-writing-data">
<h3>Reading and Writing Data<a class="headerlink" href="#reading-and-writing-data" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/loading_and_saving_objects"></span><div class="section" id="loading-and-saving-objects">
<h3>Loading and Saving Objects<a class="headerlink" href="#loading-and-saving-objects" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/handling_metadata"></span><div class="section" id="handling-metadata">
<span id="label-handling-metadata"></span><h3>Handling Metadata<a class="headerlink" href="#handling-metadata" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/downsampling"></span><div class="section" id="downsampling">
<h3>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/data_exploration"></span><div class="section" id="data-exploration">
<h3>Data Exploration<a class="headerlink" href="#data-exploration" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/blocking"></span><div class="section" id="blocking">
<h3>Blocking<a class="headerlink" href="#blocking" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/debugging_blocker_output"></span><div class="section" id="debugging-blocker-output">
<h3>Debugging Blocker Output<a class="headerlink" href="#debugging-blocker-output" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/combining_blocker_outputs"></span><div class="section" id="combining-blocker-outputs">
<h3>Combining Blocker Outputs<a class="headerlink" href="#combining-blocker-outputs" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/sampling"></span><div class="section" id="sampling">
<h3>Sampling<a class="headerlink" href="#sampling" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/labeling"></span><div class="section" id="labeling">
<h3>Labeling<a class="headerlink" href="#labeling" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/handling_features"></span><div class="section" id="handling-features">
<h3>Handling Features<a class="headerlink" href="#handling-features" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/creating_the_features_automatically"></span><div class="section" id="creating-the-features-automatically">
<h4>Creating the Features Automatically<a class="headerlink" href="#creating-the-features-automatically" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/creating_the_features_manually"></span><div class="section" id="creating-the-features-manually">
<h4>Creating the Features Manually<a class="headerlink" href="#creating-the-features-manually" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/adding_features"></span><div class="section" id="adding-features-to-feature-table">
<h4>Adding Features to Feature Table<a class="headerlink" href="#adding-features-to-feature-table" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/extracting_feature_vectors"></span><div class="section" id="extracting-feature-vectors">
<h4>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/imputing_missing_values"></span><div class="section" id="imputing-missing-values">
<h4>Imputing Missing Values<a class="headerlink" href="#imputing-missing-values" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/supported_similarity_functions"></span><div class="section" id="supported-similarity-functions">
<h4>Supported Similarity Functions<a class="headerlink" href="#supported-similarity-functions" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/supported_tokenizers"></span><div class="section" id="supported-tokenizers">
<h4>Supported Tokenizers<a class="headerlink" href="#supported-tokenizers" title="Permalink to this headline">¶</a></h4>
</div>
</div>
</div>
<span id="document-user_manual/api/matching"></span><div class="section" id="matching">
<h3>Matching<a class="headerlink" href="#matching" title="Permalink to this headline">¶</a></h3>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/splitting_data_into_train_test"></span><div class="section" id="splitting-data-into-train-and-test">
<h4>Splitting Data into Train and Test<a class="headerlink" href="#splitting-data-into-train-and-test" title="Permalink to this headline">¶</a></h4>
</div>
<span id="document-user_manual/api/supported_matchers"></span><div class="section" id="supported-matchers">
<h4>Supported Matchers<a class="headerlink" href="#supported-matchers" title="Permalink to this headline">¶</a></h4>
<div class="section" id="ml-matchers">
<h5>ML Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="rule-based-matcher">
<h5>Rule-Based Matcher<a class="headerlink" href="#rule-based-matcher" title="Permalink to this headline">¶</a></h5>
</div>
</div>
<span id="document-user_manual/api/selecting_matcher"></span><div class="section" id="selecting-matcher">
<h4>Selecting Matcher<a class="headerlink" href="#selecting-matcher" title="Permalink to this headline">¶</a></h4>
</div>
</div>
</div>
<span id="document-user_manual/api/debugging_matcher"></span><div class="section" id="debugging-matcher">
<h3>Debugging Matcher<a class="headerlink" href="#debugging-matcher" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/triggers"></span><div class="section" id="triggers">
<h3>Triggers<a class="headerlink" href="#triggers" title="Permalink to this headline">¶</a></h3>
</div>
<span id="document-user_manual/api/evaluating_the_matching_output"></span><div class="section" id="evaluating-the-matching-output">
<h3>Evaluating the Matching Output<a class="headerlink" href="#evaluating-the-matching-output" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>
<div class="section" id="experimental-commands">
<h2>Experimental Commands<a class="headerlink" href="#experimental-commands" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<span id="document-user_manual/api/dask_commands"></span><div class="section" id="commands-implemented-using-dask">
<h3>Commands Implemented Using Dask<a class="headerlink" href="#commands-implemented-using-dask" title="Permalink to this headline">¶</a></h3>
<div class="section" id="downsampling">
<h4>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="blocking">
<h4>Blocking<a class="headerlink" href="#blocking" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="extracting-feature-vectors">
<h4>Extracting Feature Vectors<a class="headerlink" href="#extracting-feature-vectors" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="ml-matchers">
<h4>ML-Matchers<a class="headerlink" href="#ml-matchers" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<span id="document-user_manual/api/tuners"></span><div class="section" id="tuners-for-the-dask-based-commands">
<h3>Tuners for the Dask-based Commands<a class="headerlink" href="#tuners-for-the-dask-based-commands" title="Permalink to this headline">¶</a></h3>
<div class="section" id="downsampling">
<h4>Downsampling<a class="headerlink" href="#downsampling" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="overlap-blocker">
<h4>Overlap Blocker<a class="headerlink" href="#overlap-blocker" title="Permalink to this headline">¶</a></h4>
</div>
</div>
<span id="document-user_manual/api/combiner"></span><div class="section" id="matcher-combiner">
<h3>Matcher Combiner<a class="headerlink" href="#matcher-combiner" title="Permalink to this headline">¶</a></h3>
</div>
</div>
</div>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


                    </div>
                </div>
            </div>

            
            <div class="clearer"></div>
        </div>
    </div>
</div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">py_entitymatching 0.3.2 documentation</a> &#187;</li> 
      </ul>
    </div>
<style type="text/css">
    .scrollToTop {
        text-align: center;
        font-weight: bold;
        position: fixed;
        bottom: 60px;
        right: 40px;
        display: none;
    }
</style>
<a href="#" class="scrollToTop">Scroll To Top</a>
<script type="text/javascript">
$(document).ready(function() {
    //Check to see if the window is top if not then display button
    $(window).scroll(function() {
        if ($(this).scrollTop() > 200) {
            $('.scrollToTop').fadeIn();
        } else {
            $('.scrollToTop').fadeOut();
        }
    });

    //Click event to scroll to top
    $('.scrollToTop').click(function() {
        $('html, body').animate({
            scrollTop: 0
        }, 500);
        return false;
    });
});
</script>
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-27880019-2']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

  </body>
</html>
